<?xml version="1.0" encoding="UTF-8" standalone="yes" ?><interaction not-production="not-production" id="se.overview"><data id="" /><data id="" /><data id="" /><data id="" /><data id="" /><vse-collection><vse-config elt-id="2025" max-elt-id="2117"><crawler elt-id="2026"><crawl-urls><crawl-url url="smb://testbed5.test.vivisimo.com/testfiles/test_data/document/TXT/C_coding_style.txt" /></crawl-urls><crawl-condition-when field="protocol"><crawl-pattern><![CDATA[smb]]></crawl-pattern><crawl-condition-when field="host" how="wc-set"><crawl-pattern><![CDATA[testbed5.test.vivisimo.com]]></crawl-pattern><crawl-condition-when field="user" how="wc-set"><crawl-pattern><![CDATA[*]]></crawl-pattern><crawl-condition-when field="path"><crawl-pattern><![CDATA[/testfiles/test_data/document/TXT/*]]></crawl-pattern><curl-options><curl-option name="default-allow"><![CDATA[allow]]></curl-option><curl-option name="user-password"><![CDATA[\gaw:{vcrypt}TMWiymi8UsQ9QvtqWkxuhw==]]></curl-option></curl-options></crawl-condition-when></crawl-condition-when></crawl-condition-when></crawl-condition-when><crawl-extender protocol="smb" exec="%java -Djpf.plugin.home='/srv/www/htdocs/vivisimo/lib/java/plugins' -classpath %classpath -Xmx160m -XX:+DisplayVMOutputToStderr -XX:+HeapDumpOnOutOfMemoryError -Djava.io.tmpdir='/srv/www/htdocs/vivisimo/tmp' -Dviv.bootstrap.logging=',off' com.vivisimo.connector.ConnectorRunner" dns="dns"><crawl-extender-option name="classname"><![CDATA[com.vivisimo.connector.SMBConnector]]></crawl-extender-option></crawl-extender><crawl-condition-when field="query" how="wc-set"><crawl-pattern><![CDATA[N=A
N=D
M=A
M=D
S=A
S=D
D=A
D=D]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[N M S D]]></curl-option></curl-options></crawl-condition-when><crawl-may-not-have field="path"><crawl-pattern><![CDATA[*.aif
*.arc
*.aiff
*.asf
*.au
*.avi
*.bin
*.bmp
*.cab
*.class
*.dbx
*.dll
*.exe
*.fpt
*.gif
*.img
*.iso
*.jar
*.jpeg
*.jpg
*.kpg
*.lib
*.max
*.mdb
*.mp3
*.mp4
*.mpa
*.mpg
*.mpeg
*.mov
*.moov
*.msi
*.ns2
*.ns3
*.ns4
*.ocx
*.ogg
*.p65
*.pfc
*.png
*.psd
*.qt
*.qxd
*.ra
*.ram
*.rpm
*.rm
*.sea
*.so
*.smi
*.smil
*.swp
*.sys
*.tif
*.tiff
*.tmb
*.vsd
*.wav
*.wma
*.wmv
*.ymg
*.yps
~$*.doc
*/~$*.doc
*/Thumbs.db
]]></crawl-pattern></crawl-may-not-have><crawl-condition-when field="path"><crawl-pattern><![CDATA[*/bugzilla/*.cgi]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[bug_status email1 emailtype1 emailassigned_to1 emailreporter1 order]]></curl-option></curl-options><crawl-may-not-have field="path"><crawl-pattern><![CDATA[*/bugzilla/showdependencytree.cgi
*/bugzilla/long_list.cgi
*/bugzilla/show_activity.cgi
*/bugzilla/showdependencygraph.cgi]]></crawl-pattern></crawl-may-not-have></crawl-condition-when><crawl-may-not-have field="path"><crawl-pattern><![CDATA[/d[0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9](/[^/]*)?]]></crawl-pattern></crawl-may-not-have><crawl-may-not-have><crawl-pattern><![CDATA[*/webcalendar/view.asp*
*/webcalendar/seclogin.asp*
*/webcalendar/reg.asp*]]></crawl-pattern></crawl-may-not-have><crawl-may-not-have><crawl-pattern><![CDATA[*/webevent.cgi?*cmd=*cal=*
*/webevent.cgi?*cal=*cmd=* ]]></crawl-pattern></crawl-may-not-have><crawl-condition-when field="protocol" how="wc-set"><crawl-pattern><![CDATA[file
exec
smb]]></crawl-pattern><crawl-condition-when field="host" how="wc"><crawl-pattern><![CDATA[?*]]></crawl-pattern><curl-options><curl-option name="delay"><![CDATA[0]]></curl-option></curl-options></crawl-condition-when><crawl-condition-except field="host" how="wc"><crawl-pattern><![CDATA[?*]]></crawl-pattern><curl-options><curl-option name="delay"><![CDATA[0]]></curl-option></curl-options></crawl-condition-except></crawl-condition-when><crawl-condition-when field="url" how="cregex"><crawl-pattern><![CDATA[\.nsf(/[^/]*)?\?Open(View|Database)(&.*)?$]]></crawl-pattern><curl-options><curl-option name="case-normalize"><![CDATA[url]]></curl-option><curl-option name="remove-cgi-parameters"><![CDATA[Collapse Expand Count ExpandView Start]]></curl-option></curl-options><crawl-replace this="&amp;*$" that="&amp;start=1&amp;Count=10000&amp;ExpandView" /></crawl-condition-when><crawl-condition-when field="path" how="cregex"><crawl-pattern><![CDATA[\.nsf(/[^/]*)*/[a-f0-9]{32}?$]]></crawl-pattern><crawl-condition-when field="path" how="wc-set"><crawl-pattern><![CDATA[*/$file/*]]></crawl-pattern><curl-options><curl-option name="case-normalize"><![CDATA[url]]></curl-option></curl-options><crawl-replace this="\.[nN][Ss][Ff]/[a-fA-F0-9]{32}" that=".nsf/0" /></crawl-condition-when><crawl-condition-when field="query" how="wc-set"><crawl-pattern><![CDATA[OpenDocument
OpenDocument&*
]]></crawl-pattern><curl-options><curl-option name="case-normalize"><![CDATA[url]]></curl-option></curl-options><crawl-replace this="\.[nN][Ss][Ff]/[a-fA-F0-9]{32}" that=".nsf/0" /></crawl-condition-when><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[Collapse Expand Count ExpandView Start ExpandSection]]></curl-option></curl-options></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[*&sid=*]]></crawl-pattern><crawl-replace this="&amp;sid=[^&amp;]*" that="&amp;sid=0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[sid=*]]></crawl-pattern><crawl-replace this="\?sid=[^&amp;]*" that="?sid=0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[*&PHPSESSID=*]]></crawl-pattern><crawl-replace this="&amp;PHPSESSID=[^&amp;]*" that="&amp;PHPSESSID=0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[PHPSESSID=*]]></crawl-pattern><crawl-replace this="\?PHPSESSID=[^&amp;]*" that="?PHPSESSID=0" /></crawl-condition-when><crawl-condition-when field="path"><crawl-pattern><![CDATA[*;jsessionid=*]]></crawl-pattern><crawl-replace this="%3[bB]jsessionid%3[dD][^?]*" that="%3Bjsessionid%3D0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[*__VIEWSTATE=*]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[__VIEWSTATE]]></curl-option></curl-options></crawl-condition-when><crawl-may-not-have field="query"><crawl-pattern><![CDATA[*&MSCSProfile=*
MSCSProfile=*]]></crawl-pattern></crawl-may-not-have><crawl-condition-when field="port"><crawl-pattern><![CDATA[8765]]></crawl-pattern><curl-options /><crawl-may-not-have field="path"><crawl-pattern><![CDATA[query.html]]></crawl-pattern></crawl-may-not-have></crawl-condition-when><crawl-condition-when field="path"><crawl-pattern><![CDATA[*/wiki/*]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[action previous version]]></curl-option></curl-options></crawl-condition-when><crawl-condition-when field="path"><crawl-pattern><![CDATA[*/bugzilla/*.cgi]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[bug_status email1 emailtype1 emailassigned_to1 emailreporter1 order]]></curl-option></curl-options><crawl-may-not-have field="path"><crawl-pattern><![CDATA[*/bugzilla/showdependencytree.cgi
*/bugzilla/long_list.cgi
*/bugzilla/show_activity.cgi
*/bugzilla/showdependencygraph.cgi]]></crawl-pattern></crawl-may-not-have></crawl-condition-when></crawler><vse-index elt-id="2036"><vse-index-option name="output-contents" elt-id="2037"><![CDATA[title]]></vse-index-option><vse-index-option name="summarize-contents" elt-id="2038"><![CDATA[snippet]]></vse-index-option><vse-index-option name="fast-index" elt-id="2039"><![CDATA[last-modified|date]]></vse-index-option><vse-url-equivs name="vse-url-equivs" elt-id="2040"><vse-url-equiv old-prefix="smb://" new-prefix="file://///" elt-id="2041" /></vse-url-equivs></vse-index><converters elt-id="2042"><converter type-in="unknown" type-out="dead" elt-id="2043" timing-name="Binary file extensions (filter)"><converter-test what="url" how="wc-set"><![CDATA[*#*.aif
*#*.arc
*#*.aiff
*#*.asf
*#*.au
*#*.avi
*#*.bin
*#*.bmp
*#*.cab
*#*.class
*#*.dbx
*#*.dll
*#*.exe
*#*.fpt
*#*.gif
*#*.img
*#*.iso
*#*.jar
*#*.jpeg
*#*.jpg
*#*.kpg
*#*.lib
*#*.max
*#*.mdb
*#*.mp3
*#*.mp4
*#*.mpa
*#*.mpg
*#*.mpeg
*#*.mov
*#*.moov
*#*.msi
*#*.ns2
*#*.ns3
*#*.ns4
*#*.ocx
*#*.ogg
*#*.p65
*#*.pfc
*#*.png
*#*.psd
*#*.qt
*#*.qxd
*#*.ra
*#*.ram
*#*.rpm
*#*.rm
*#*.sea
*#*.so
*#*.smi
*#*.smil
*#*.swp
*#*.sys
*#*.tif
*#*.tiff
*#*.tmb
*#*.vsd
*#*.wav
*#*.wma
*#*.wmv
*#*.ymg
*#*.yps
*#~$*.doc
*#*/~$*.doc
*#*/Thumbs.db
]]></converter-test></converter><converter type-in="unknown" program="guess-content %source_file" timing-name="Guess content" elt-id="2045" /><converter type-in="application/ms-office" program="ms-guess %source_file" timing-name="Guess MS Office" elt-id="2046" /><converter type-in="unknown" type-out="text/plain" elt-id="2047"><converter-test how="wc-set" what="path" elt-id="2048"><![CDATA[*.txt]]></converter-test></converter><converter type-in="application/word" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="doc" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">doc</content>']]></converter-execute></converter><converter type-in="application/excel" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="xls" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">xls</content>']]></converter-execute></converter><converter type-in="application/powerpoint" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="ppt" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">ppt</content>']]></converter-execute></converter><converter type-in="application/ps" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="ps" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">ps</content>']]></converter-execute></converter><converter type-in="application/pdf" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="pdf" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">pdf</content>']]></converter-execute></converter><converter type-in="application/rtf" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="rtf" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">rtf</content>']]></converter-execute></converter><converter type-in="application/vnd.lotus-1-2-3" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="lotus123" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">lotus123</content>']]></converter-execute></converter><converter type-in="application/vnd.ms-project" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="msproject" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">msproject</content>']]></converter-execute></converter><converter type-in="application/outlook-msg" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="email" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">email</content>']]></converter-execute></converter><converter type-in="text/mail" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="email" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">email</content>']]></converter-execute></converter><converter type-in="application/vnd.sun.xml.writer" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="sxw" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">sxw</content>']]></converter-execute></converter><converter type-in="application/vnd.sun.xml.calc" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="sxc" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">sxc</content>']]></converter-execute></converter><converter type-in="application/vnd.sun.xml.impress" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="sxi" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">sxi</content>']]></converter-execute></converter><converter type-in="application/vnd.sun.xml.draw" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="sxd" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">sxd</content>']]></converter-execute></converter><converter type-in="application/vnd.sun.xml.math" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="sxm" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">sxm</content>']]></converter-execute></converter><converter type-in="message/rfc822" type-out="text/mail" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.writer" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.calc" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.impress" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.draw" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.math" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/octet-stream" type-out="unknown" timing-name="Type normalization" /><converter type-in="application/postscript" type-out="application/ps" timing-name="Type normalization" /><converter type-in="application/msword" type-out="application/word" timing-name="Type normalization" /><converter type-in="application/vnd.ms-pps" type-out="application/powerpoint" timing-name="Type normalization" /><converter type-in="application/vnd.ms-powerpoint" type-out="application/powerpoint" timing-name="Type normalization" /><converter type-in="application/vnd.ms-excel" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/vnd.ms-word" type-out="application/word" timing-name="Type normalization" /><converter type-in="application/wordperfect5.1" type-out="application/wordperfect" timing-name="Type normalization" /><converter type-in="application/wordperfect6.1" type-out="application/wordperfect" timing-name="Type normalization" /><converter type-in="application/wordperfectd" type-out="application/wordperfect" timing-name="Type normalization" /><converter type-in="application/x-tar" type-out="application/tar" timing-name="Type normalization" /><converter type-in="application/x-zip" type-out="application/zip" timing-name="Type normalization" /><converter type-in="application/x-zip-compressed" type-out="application/zip" timing-name="Type normalization" /><converter type-in="application/x-shockwave-flash" type-out="application/flash" timing-name="Type normalization" /><converter type-in="application/shockwave-flash" type-out="application/flash" timing-name="Type normalization" /><converter type-in="unknown" type-out="application/temp" timing-name="Type normalization"><converter-test what="path" how="wc-set"><![CDATA[
*~
*.tmp
  ]]></converter-test></converter><converter type-in="application/word" type-out="application/rtf" timing-name="Type normalization"><converter-test how="wc-set" what="body"><![CDATA[{\rtf*]]></converter-test></converter><converter type-in="application/vxml-db" type-out="application/vxml-unnormalized" elt-id="2051" timing-name="Database seeds support"><parser type="xsl"><![CDATA[
  <xsl:variable name="title"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="action"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="abstract"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="urlparam"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="key"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="key-normalize"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="url-table"><![CDATA[true()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="content-type"><![CDATA['text']]]><![CDATA[]></xsl:variable>

  <xsl:variable name="urlproto"><![CDATA[false()]]]><![CDATA[]></xsl:variable>
 
<xsl:template match="/">
  <vce>
  <xsl:variable name="errors" select="//error" />
  <xsl:if test="$errors">
    <xsl:message>
      <xsl:value-of select="viv:concat($errors//text(), ' ')" />
    </xsl:message>
  </xsl:if>
  <xsl:for-each select="//more-results[viv:test(@start, '^[0-9]*$', 'regex')]">
    <xsl:choose>
      <xsl:when test="contains($crawl-url-url, '%java -classpath')">
        <xsl:variable name="url" select="concat(viv:replace($crawl-url-url, '--start [0-9]*$', ''), ' --start ', @start)" />
        <xsl:value-of select="viv:crawl-enqueue-url($url)" />
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="url" select="concat(viv:replace($crawl-url-url, '-s [0-9]*$', ''), ' -s ', @start)" />
        <xsl:value-of select="viv:crawl-enqueue-url($url)" />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>
  <xsl:apply-templates select="//document" />
  </vce>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:apply-templates select="*|text()|comment()|@*"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="text()|comment()|@*">
  <xsl:copy-of select="."/>
</xsl:template>

<xsl:template match="content|text()" mode="title">
  <xsl:param name="key"/>
  <xsl:param name="key-normalized"/>
  <xsl:param name="pos"/>

  <xsl:value-of select="viv:set(concat('title', @name), .)"/> 
  <content>
    <xsl:apply-templates select="@*" />
    <xsl:if test="string-length($key-normalized) > 0 and $key">
      <xsl:attribute name="vse-add-to-normalized">
        <xsl:value-of select="'vse-add-to-normalized'"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$key">
      <xsl:attribute name="add-to"><xsl:value-of select="$key"/></xsl:attribute>
    </xsl:if>
    <xsl:attribute name="name">title</xsl:attribute>
    <xsl:attribute name="type">
      <xsl:choose>
        <xsl:when test="dyn:evaluate($content-type)">
          <xsl:value-of select="dyn:evaluate($content-type)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>text</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>

    <xsl:if test="dyn:evaluate($action)">
      <xsl:attribute name="action"><xsl:value-of select="dyn:evaluate($action)"/></xsl:attribute>
    </xsl:if>

    <xsl:if test="dyn:evaluate($weight)">
      <xsl:variable name="weight-val">
        <xsl:value-of select="dyn:evaluate($weight)"/>
      </xsl:variable>

      <xsl:if test="viv:test($weight-val, '^[0-9.]+$', 'regex')">
        <xsl:attribute name="weight"><xsl:value-of select="dyn:evaluate($weight)"/></xsl:attribute>
      </xsl:if>
    </xsl:if>

    <xsl:if test="dyn:evaluate($output-action)">
      <xsl:attribute name="output-action"><xsl:value-of select="dyn:evaluate($output-action)"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="dyn:evaluate($value-mapping)"><xsl:value-of select="dyn:evaluate($value-mapping)"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
</xsl:template>

<xsl:template match="content|text()" mode="abstract">
  <xsl:param name="key"/>
  <xsl:param name="key-normalized"/>
  <xsl:param name="pos"/>

  <xsl:value-of select="viv:set(concat('abstract', @name), .)"/>

  <content>
    <xsl:apply-templates select="@*[not(name)]" />
    <xsl:if test="string-length($key-normalized) > 0 and $key">
      <xsl:attribute name="vse-add-to-normalized">
        <xsl:value-of select="'vse-add-to-normalized'"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$key">
      <xsl:attribute name="add-to"><xsl:value-of select="$key"/></xsl:attribute>
    </xsl:if>
    <xsl:attribute name="name">abstract</xsl:attribute>
    <xsl:if test="dyn:evaluate($action)">
      <xsl:attribute name="action"><xsl:value-of select="dyn:evaluate($action)"/></xsl:attribute>
    </xsl:if>

    <xsl:attribute name="type">
      <xsl:choose>
        <xsl:when test="dyn:evaluate($content-type)">
          <xsl:value-of select="dyn:evaluate($content-type)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>text</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>
    <xsl:if test="dyn:evaluate($weight)">
      <xsl:variable name="weight-val">
        <xsl:value-of select="dyn:evaluate($weight)"/>
      </xsl:variable>

      <xsl:if test="viv:test($weight-val, '^[0-9.]+$', 'regex')">
        <xsl:attribute name="weight"><xsl:value-of select="dyn:evaluate($weight)"/></xsl:attribute>
      </xsl:if>
    </xsl:if>
    <xsl:if test="dyn:evaluate($output-action)">
      <xsl:attribute name="output-action"><xsl:value-of select="dyn:evaluate($output-action)"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="dyn:evaluate($value-mapping)"><xsl:value-of select="dyn:evaluate($value-mapping)"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
</xsl:template>

<xsl:template match="content">
  <xsl:param name="key"/>
  <xsl:param name="key-normalized"/>
  <xsl:param name="pos"/>

  <xsl:if test="not(. = viv:get(concat('title', @name))) and not(. = viv:get(concat('abstract', @name)))">
  <content>
    <xsl:apply-templates select="@*"/>
    <xsl:if test="string-length($key-normalized) > 0 and $key">
      <xsl:attribute name="vse-add-to-normalized">
        <xsl:value-of select="'vse-add-to-normalized'"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$key">
      <xsl:attribute name="add-to"><xsl:value-of select="$key"/></xsl:attribute>
    </xsl:if>

    <xsl:attribute name="type">
      <xsl:choose>
        <xsl:when test="dyn:evaluate($content-type)">
          <xsl:value-of select="dyn:evaluate($content-type)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>text</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>
    <xsl:if test="dyn:evaluate($mapping)">
      <xsl:attribute name="name"><xsl:value-of select="dyn:evaluate($mapping)"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="dyn:evaluate($action)">
      <xsl:attribute name="action"><xsl:value-of select="dyn:evaluate($action)"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="dyn:evaluate($weight)">
      <xsl:variable name="weight-val">
        <xsl:value-of select="dyn:evaluate($weight)"/>
      </xsl:variable>

      <xsl:if test="viv:test($weight-val, '^[0-9.]+$', 'regex')">
        <xsl:attribute name="weight"><xsl:value-of select="dyn:evaluate($weight)"/></xsl:attribute>
      </xsl:if>
    </xsl:if>
    <xsl:if test="dyn:evaluate($output-action)">
      <xsl:attribute name="output-action"><xsl:value-of select="dyn:evaluate($output-action)"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="dyn:evaluate($value-mapping)"><xsl:value-of select="dyn:evaluate($value-mapping)"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
  </xsl:if>
</xsl:template>

<xsl:template match="document">
  <xsl:variable name="keyval" select="dyn:evaluate($key)"/>
  <xsl:variable name="url" select="dyn:evaluate($urlparam)"/>
  <xsl:variable name="urltable" select="dyn:evaluate($url-table)"/>

  <xsl:choose>
    <xsl:when test="dyn:evaluate($url-table)">
      <document>
        <xsl:copy-of select="@*"/>
        <xsl:if test="string-length($key-normalize) > 0">
          <xsl:attribute name="vse-key-normalized">
            <xsl:value-of select="'vse-key-normalized'"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:if test="dyn:evaluate($key)">
          <xsl:attribute name="vse-key"><xsl:value-of select="$keyval"/></xsl:attribute>
        </xsl:if>
        <xsl:if test="dyn:evaluate($urlparam)">
          <xsl:attribute name="url">
            <xsl:value-of select="viv:if-else(dyn:evaluate($urlproto), dyn:evaluate($urlproto), $url)"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:apply-templates select="dyn:evaluate($title)" mode="title">
          <xsl:with-param name="pos" select="position()"/>
        </xsl:apply-templates>
        <xsl:apply-templates select="dyn:evaluate($abstract)" mode="abstract">
          <xsl:with-param name="pos" select="position()"/>
        </xsl:apply-templates>
        <xsl:apply-templates select="*">
          <xsl:with-param name="pos" select="position()"/>
        </xsl:apply-templates>
      </document>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="dyn:evaluate($title)" mode="title">
        <xsl:with-param name="key" select="$keyval"/>
        <xsl:with-param name="key-normalized" select="$key-normalize"/>
        <xsl:with-param name="pos" select="position()"/>
      </xsl:apply-templates>
      <xsl:apply-templates select="dyn:evaluate($abstract)" mode="abstract">
        <xsl:with-param name="key" select="$keyval"/>
        <xsl:with-param name="key-normalized" select="$key-normalize"/>
        <xsl:with-param name="pos" select="position()"/>
      </xsl:apply-templates>
      <xsl:apply-templates select="*">
        <xsl:with-param name="key" select="$keyval"/>
        <xsl:with-param name="key-normalized" select="$key-normalize"/>
        <xsl:with-param name="pos" select="position()"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
]]></parser></converter><converter type-in="application/powerpoint" type-out="application/powerpoint-xml" timing-name="PPT to XML"><converter-execute><![CDATA[%bin/pptxml %source_file
]]></converter-execute></converter><converter type-in="application/powerpoint-xml" type-out="text/html" timing-name="PPT XML to HTML"><parser type="xsl"><![CDATA[<!-- -->

<xsl:template match="/">
  <xsl:variable name="presentation" select="/*/presentation"/>
  <xsl:variable name="meta" select="/top/summary/property" />

  <html>
    <head>
      <xsl:if test="$meta[@name='title']">
        <title><xsl:value-of select="$meta[@name='title']/@value" /></title>
      </xsl:if>
      <xsl:apply-templates select="$meta" mode="meta" />
    </head>
    <body>
      <xsl:choose>
        <xsl:when test="not($presentation/@version)">
          <xsl:call-template name="version-1"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="version-2"/>
        </xsl:otherwise>
      </xsl:choose>
    </body>
  </html>
</xsl:template>

<xsl:template mode="meta" match="*">
  <xsl:if test="@name">
    <meta name="{@name}" value="{@value}" />
  </xsl:if>
</xsl:template>

<xsl:template mode="text" match="TextCharsAtom|TextBytesAtom|CString">
  <xsl:variable name="header" select="(preceding-sibling::TextHeaderAtom[1])|(parent::TextHeaderAtom)" />
  <xsl:variable name="size">
    <xsl:choose>
      <xsl:when test="$header/@header = 0"><![CDATA[18]]]><![CDATA[]></xsl:when>
      <xsl:when test="$header/@header = 5"><![CDATA[24]]]><![CDATA[]></xsl:when>
      <xsl:when test="$header/@header = 6"><![CDATA[20]]]><![CDATA[]></xsl:when>
      <xsl:otherwise><![CDATA[0]]]><![CDATA[]></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:apply-templates select="str:tokenize(., '&#10;')" mode="nl">
    <xsl:with-param name="size" select="$size" />
  </xsl:apply-templates>
  <xsl:if test="$header/@header = '0'"><p /></xsl:if>
</xsl:template>

<xsl:template match="*" mode="nl">
  <xsl:param name="size" />

  <span>
    <xsl:if test="$size > 0">
      <xsl:attribute name="style">
        <xsl:text><![CDATA[font-size: ]]]><![CDATA[]></xsl:text>
        <xsl:value-of select="$size" />
        <xsl:text><![CDATA[pt;]]]><![CDATA[]></xsl:text>
      </xsl:attribute>
    </xsl:if>
    <xsl:value-of select="." />
  </span>
  <br />
</xsl:template>


<!-- VERSION 2 -->

<xsl:variable name="slides" select="//Slide"/>
<xsl:variable name="persist-refs" select="//persist-ref"/>

<xsl:template name="version-2">
  <xsl:variable name="lists" select="//Document/SlideListWithText[@instance=0]"/>
  <xsl:apply-templates mode="v2-body" select="$lists[position() = last()]"/>
</xsl:template>

<xsl:template mode="v2-body" match="SlidePersistAtom">
  <xsl:variable name="persist" select="."/>
  <xsl:variable name="id" select="@psrReference"/>
  <xsl:variable name="pr" select="$persist-refs[@id = $id]"/>
  <xsl:variable name="slide" select="$slides[@start = $pr/@offset]"/>

  <xsl:for-each select="$slide//msofbtClientTextbox">
    <xsl:apply-templates select="." mode="text"/>
    <xsl:for-each select=".//OutlineTextRefAtom">
      <xsl:variable name="instance" select="@ref"/>
      <xsl:apply-templates select="$persist//TextHeaderAtom[@instance = $instance]/*" mode="text"/>
    </xsl:for-each>
  </xsl:for-each>
  <hr/>
</xsl:template>
    

<!-- VERSION 1 -->

<xsl:template name="version-1">
  <xsl:variable name="slides" select="//Document//SlideListWithText[TextHeaderAtom]" />
  <xsl:variable name="slide" select="$slides[position() = last()]" />
  <xsl:apply-templates mode="v1-body" select="$slide" />
</xsl:template>

<xsl:template mode="v1-body" match="TextCharsAtom|TextBytesAtom|CString">
  <xsl:apply-templates mode="text" select="."/>
</xsl:template>

<xsl:template mode="v1-body" match="*">
  <xsl:apply-templates mode="v1-body" select="*" />
</xsl:template>

<xsl:template mode="v1-body" match="SlidePersistAtom">
  <hr />
</xsl:template>
]]></parser></converter><converter type-in="application/vnd.lotus-1-2-3" type-out="application/vnd.lotus-1-2-3-text" timing-name="Lotus 1-2-3"><converter-execute><![CDATA[vstrings --window 4 --min-char-pct 1 --min-space-pct 0 %source_file]]></converter-execute></converter><converter type-in="application/vnd.lotus-1-2-3-text" type-out="text/plain" timing-name="Lotus 1-2-3"><parser type="regex-text"><match token="^[8DP\\]?['\^&quot;]" goto="keep" /><state name="keep"><match token="$[8DP\\]?['\^&quot;]" goto="keep"><add-string><![CDATA[; ]]></add-string></match><match token="$" goto="discard" /><add-string /></state><state name="discard"><match token="^[8DP\\]?['\^&quot;]" goto="keep"><add-string><![CDATA[; ]]></add-string></match></state></parser></converter><converter type-in="outlook/mail" type-out="text/mailbox" elt-id="2055" timing-name="PST (Outlook) to mailbox"><converter-execute><![CDATA[%bin/readpst -w -r -o %target_dir %source_file > /dev/null]]></converter-execute></converter><converter type-in="text/mailbox" type-out="text/mail" elt-id="2057" timing-name="Mailbox to messages"><converter-execute><![CDATA[%bin/split-mail %target_dir]]></converter-execute></converter><converter type-in="text/mail" type-out="vivisimo/crawl-data" elt-id="2059" timing-name="Email message"><converter-execute><![CDATA[%bin/mail2vxml --parser vse-cache-parser-email --anchor %anchor 'snippet' 'subject=title' '*date' '*from' '*to']]></converter-execute></converter><converter type-in="application/documentum" type-out="application/vxml-unnormalized" elt-id="2062" timing-name="Documentum documents"><parser type="xsl"><![CDATA[
  <xsl:variable name="action"><![CDATA[viv:choose($name = 'title' or $name = 'description','cluster', 'none')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[viv:choose($name = 'title',3,1)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[viv:choose($name = 'description' or $name = 'title' or $name = 'author', 'bold')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[viv:choose(@name = 'title', 'title', @name = 'subject', 'description', @name = 'r_modified_date', 'last-modified', @name = 'r_modifier', 'author')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[viv:choose($name = 'last-modified', concat(date:month-name(.), ' ',date:day-in-month(.),', ',date:year(.)))]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <vce>
    <xsl:apply-templates/>
  </vce>
</xsl:template>

<xsl:template match="vce">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:apply-templates select="*"/>
  </xsl:copy>
</xsl:template>


<xsl:template match="document">
  <xsl:variable name="urlroot" select="content[@name='url_root']"/>
  <xsl:variable name="objectid" select="content[@name='r_object_id']"/>
  <xsl:copy>
    <xsl:copy-of select="@*[name(.)!='id']"/>
    <xsl:if test="$urlroot and $objectid">
      <xsl:attribute name="url">
        <xsl:value-of select="concat($urlroot,$objectid)"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:apply-templates select="content"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:variable name="name" select="dyn:evaluate($mapping)"/>
  <xsl:variable name="a" select="dyn:evaluate($action)"/>
  <xsl:variable name="w" select="dyn:evaluate($weight)"/>
  <xsl:variable name="oa" select="dyn:evaluate($output-action)"/>
  <xsl:variable name="vm" select="dyn:evaluate($value-mapping)"/> 
  <xsl:if test="$name">
  <content>
    <xsl:copy-of select="@*"/>
    <xsl:attribute name="name"><xsl:value-of select="$name"/></xsl:attribute>
    <xsl:if test="$a">
      <xsl:attribute name="action"><xsl:value-of select="$a"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$w">
      <xsl:attribute name="weight"><xsl:value-of select="$w"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$oa">
      <xsl:attribute name="output-action"><xsl:value-of select="$oa"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$vm"><xsl:value-of select="$vm"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
  </xsl:if>
</xsl:template>



]]></parser></converter><converter type-in="application/eroom" type-out="application/vxml-unnormalized" elt-id="2064" timing-name="eRoom documents"><parser type="xsl"><![CDATA[
  <xsl:variable name="action"><![CDATA[viv:choose($name = 'title' or $name = 'description','cluster', 'none')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[viv:choose($name = 'title',3,1)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[viv:choose(@name = 'Name', 'title', @name = 'Description', 'snippet', @name = 'ModifyDate', 'last-modified', @name)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[viv:choose($name = 'last-modified', concat(date:month-name(.), ' ',date:day-in-month(.),', ',date:year(.)))]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <vce>
    <xsl:apply-templates/>
  </vce>
</xsl:template>

<xsl:template match="vce">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:apply-templates select="*"/>
  </xsl:copy>
</xsl:template>


<xsl:template match="document">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates select="content"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:variable name="name" select="dyn:evaluate($mapping)"/>
  <xsl:variable name="a" select="dyn:evaluate($action)"/>
  <xsl:variable name="w" select="dyn:evaluate($weight)"/>
  <xsl:variable name="oa" select="dyn:evaluate($output-action)"/>
  <xsl:variable name="vm" select="dyn:evaluate($value-mapping)"/> 
  <xsl:if test="$name">
  <content>
    <xsl:copy-of select="@*"/>
    <xsl:attribute name="name"><xsl:value-of select="$name"/></xsl:attribute>
    <xsl:if test="$a">
      <xsl:attribute name="action"><xsl:value-of select="$a"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$w">
      <xsl:attribute name="weight"><xsl:value-of select="$w"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$oa">
      <xsl:attribute name="output-action"><xsl:value-of select="$oa"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$vm"><xsl:value-of select="$vm"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
  </xsl:if>
</xsl:template>



]]></parser></converter><converter type-out="application/vxml-unnormalized" type-in="application/lotus" elt-id="2066" timing-name="Lotus documents"><parser type="xsl"><![CDATA[
  <xsl:variable name="action"><![CDATA[viv:choose($name = 'title','cluster', 'none')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[viv:choose($name = 'title',3,1)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[viv:choose($name = 'snippet', 'summarize', '')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[viv:choose(@name = 'Subject', 'title', @name = 'Body', 'snippet')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[viv:choose($name = 'last-modified', concat(date:month-name(.), ' ',date:day-in-month(.),', ',date:year(.)))]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <vce>
    <xsl:apply-templates/>
  </vce>
</xsl:template>

<xsl:template match="vce">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:apply-templates select="*"/>
  </xsl:copy>
</xsl:template>


<xsl:template match="document">
  <xsl:variable name="urlroot" select="content[@name='url_root']"/>
  <xsl:variable name="objectid" select="content[@name='r_object_id']"/>
  <xsl:copy>
    <xsl:copy-of select="@*[name(.)!='id']"/>
    <xsl:if test="$urlroot and $objectid">
      <xsl:attribute name="url">
        <xsl:value-of select="concat($urlroot,$objectid)"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:apply-templates select="content"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:variable name="name" select="dyn:evaluate($mapping)"/>
  <xsl:variable name="a" select="dyn:evaluate($action)"/>
  <xsl:variable name="w" select="dyn:evaluate($weight)"/>
  <xsl:variable name="oa" select="dyn:evaluate($output-action)"/>
  <xsl:variable name="vm" select="dyn:evaluate($value-mapping)"/> 

  <content>
    <xsl:copy-of select="@*"/>
    <xsl:if test="$name">
      <xsl:attribute name="name"><xsl:value-of select="$name"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$a">
      <xsl:attribute name="action"><xsl:value-of select="$a"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$w">
      <xsl:attribute name="weight"><xsl:value-of select="$w"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$oa">
      <xsl:attribute name="output-action"><xsl:value-of select="$oa"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$vm"><xsl:value-of select="$vm"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
</xsl:template>



]]></parser></converter><converter type-in="application/sharepoint" type-out="application/vxml-unnormalized" elt-id="2068" timing-name="Sharepoint Documents"><parser type="xsl"><![CDATA[
  <xsl:variable name="action"><![CDATA[viv:choose($name = 'title' or $name = 'description','cluster', 'none')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[viv:choose($name = 'title',3,1)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[viv:choose($name  = 'description' or $name = 'title' or $name = 'author', 'bold')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[viv:choose(@name = 'Title' or @name = 'Description' or @name = 'Author', viv:str-to-lower(@name), @name = 'ows_Title' or @name = 'ows_Author', viv:str-to-lower(substring-after(@name, 'ows_')), @name = 'ows_Body' or @name ='ows_PublishingPageContent', 'snippet', @name = 'LastModified' or @name = 'ows_Modified', 'last-modified')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[dyn:evaluate(viv:choose($name='author', "viv:replace(.,'^[[:digit:]]+;#','')"))]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <xsl:choose>
    <xsl:when test="viv:vivisimo-version-is-newer-than('5.0-5')">
      <vce>
        <xsl:apply-templates select="//document"/>
      </vce>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="v" select="viv:vivisimo-alloc()"/>
      <xsl:variable name="cn" select="viv:current-node(true())"/>
      <xsl:variable name="up" select="$cn/curl-options/curl-option[@name='user-password']"/>
      <xsl:variable name="xml">
        <declare name="no-recurse" initial-value="{viv:current-node()/@no-recurse}"/>
        <declare name="default-acl" initial-value="{viv:current-node()/@default-acl}"/>
        <call-function name="sharepoint-crawl">
          <with name="site-url"><xsl:value-of select="viv:replace($cn/@url,'\/*default.aspx$','')"/></with>
          <xsl:if test="$up">
            <with name="username"><xsl:value-of select="substring-before($up,':')"/></with>
            <with name="password"><xsl:value-of select="substring-after($up,':')"/></with>
          </xsl:if>
        </call-function>  
        <fetch timeout="300000" finish="finish"/>
      </xsl:variable>
      <xsl:value-of select="viv:vivisimo-input-xml($v, $xml)"/>
      <vce>
        <xsl:variable name="oxml" select="viv:vivisimo-xml($v)"/>
        <xsl:apply-templates select="$oxml//document"/>
        <xsl:for-each select="$oxml//crawl-url">
          <xsl:value-of select="viv:crawl-enqueue-url(false(),.)"/>
        </xsl:for-each>
      </vce>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="document">
  <xsl:copy>
    <xsl:copy-of select="@*[name(.)!='id']"/>
    <xsl:apply-templates select="content"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:variable name="name" select="dyn:evaluate($mapping)"/>
  <xsl:variable name="a" select="dyn:evaluate($action)"/>
  <xsl:variable name="w" select="dyn:evaluate($weight)"/>
  <xsl:variable name="oa" select="dyn:evaluate($output-action)"/>
  <xsl:variable name="vm" select="dyn:evaluate($value-mapping)"/> 
  <xsl:if test="$name">
  <content>
    <xsl:copy-of select="@*"/>
    <xsl:attribute name="name"><xsl:value-of select="$name"/></xsl:attribute>
    <xsl:if test="$a">
      <xsl:attribute name="action"><xsl:value-of select="$a"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$w">
      <xsl:attribute name="weight"><xsl:value-of select="$w"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$oa">
      <xsl:attribute name="output-action"><xsl:value-of select="$oa"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$vm"><xsl:value-of select="$vm"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
  </xsl:if>
</xsl:template>

]]></parser></converter><converter type-in="application/word" type-out="text/html" elt-id="2070" timing-name="Microsoft Word to HTML"><converter-execute><![CDATA[%bin/wvWare -1 -x %bin/wvHtml.xml %source_file
]]></converter-execute></converter><converter type-in="application/excel" type-out="text/html" elt-id="2072" timing-name="Microsoft Excel"><converter-execute><![CDATA[%bin/xlhtml -te %source_file]]></converter-execute></converter><converter type-in="application/wordperfect" type-out="text/html" elt-id="2074" timing-name="WordPerfect to HTML"><converter-execute><![CDATA[%bin/wpd2html %source_file > %target_file]]></converter-execute></converter><converter type-in="application/openoffice" type-out="text/html" elt-id="2076" timing-name="Open Office to HTML"><converter-execute><![CDATA[unzip -pq %source_file content.xml meta.xml | o3tohtml]]></converter-execute></converter><converter type-in="application/vnd.ms-project" type-out="application/vxml-unnormalized" elt-id="2078" timing-name="Microsoft Project"><converter-execute><![CDATA[mpp2vxml --content-name snippet  %source_file]]></converter-execute></converter><converter type-in="application/ps" type-out="text/plain" elt-id="2080" timing-name="Postscript (ps) to text"><converter-execute><![CDATA[%bin/ghostscript/gs -q -dNODISPLAY -dSAFER -dDELAYBIND -dWRITESYSTEMDICT -dSIMPLE -I%bin/ghostscript -c save -f %bin/ghostscript/ps2ascii.ps %source_file -c quit > %target_file]]></converter-execute></converter><converter type-in="application/pdf" type-out="text/html" elt-id="2082" timing-name="PDF to HTML"><converter-execute><![CDATA[%bin/pdftohtml -enc UTF-8 -i -noframes -c -stdout  %source_file | %bin/check-and-fix-utf8  | %bin/fix-pdf]]></converter-execute></converter><converter type-in="application/rtf" type-out="text/html" elt-id="2084" timing-name="RTF to HTML"><converter-execute><![CDATA[%bin/rtf2html %source_file]]></converter-execute></converter><converter type-in="application/outlook-msg" type-out="vivisimo/crawl-data" elt-id="2086" timing-name="Email: Outlook (MSG) "><converter-execute><![CDATA[%bin/msg2vxml --cache-parser vse-cache-parser-email %source_file]]></converter-execute></converter><converter type-in="application/flash" type-out="text/html" elt-id="2088" timing-name="Flash to HTML"><converter-execute><![CDATA[swf2html - < %source_file > %target_file]]></converter-execute></converter><converter type-in="application/tar" type-out="unknown" elt-id="2090" timing-name="TAR archive extractor"><converter-execute><![CDATA[
tar xf %source_file --no-same-owner --force-local --no-same-permissions --directory=%target_dir  > /dev/null && chmod -R +rwx %target_dir]]></converter-execute></converter><converter type-in="application/x-gzip" type-out="unknown" elt-id="2092" timing-name="Uncompress gzip (.gz)"><converter-execute><![CDATA[gunzip -f < %source_file > %target_file]]></converter-execute></converter><converter type-in="application/zip" type-out="unknown" elt-id="2094" timing-name="Uncompress ZIP files"><converter-execute><![CDATA[unzip -o %source_file -d %target_dir && chmod -R +rwx %target_dir]]></converter-execute></converter><converter type-in="application/x-compress" type-out="unknown" elt-id="2096" timing-name="Uncompress compress (.Z) files"><converter-execute><![CDATA[%bin/compress -d -c %source_file > %target_file && chmod +rwx %target_file]]></converter-execute></converter><converter type-in="text/html" type-out="application/vxml-unnormalized" elt-id="2098" timing-name="HTML to XML"><parser type="html-xsl"><![CDATA[
  <xsl:variable name="meta-names"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="meta-action"><![CDATA[cluster-bold]]]><![CDATA[]></xsl:variable>


<!--

Convert HTML to Vivisimo XML.

This XSL stylesheet does two things.  First it selects a title for the
page.  If the page is a PDF, Word, Powerpoint or Excel document, we will
consider replacing the title in the document.  The title selection is
based on looking for large fonts near the start of the document.  You
can explore this transformation and customize it as you see fit.

The second thing that this XSLT does is to take a subset of the HTML and
put it into a content named snippet.  Near the end of this parser, there
are a series of template matches that decide which tags will be placed
into the content, which will be discard and which will be discarded along
with their sub-nodes.

-->

<xsl:output method="xml" encoding="utf-8" />
<xsl:strip-space elements="*" />

<xsl:variable name="include-alts">
</xsl:variable>

<!-- useful short-cuts -->

<xsl:variable name="generator" select="/html/head/meta[@name = 'GENERATOR']" />
<xsl:variable name="is-pdf" select="viv:test($url, '\.pdf$|\.pdf#', 'cregex')" />
<xsl:variable name="is-doc" select="starts-with($generator/@content, 'wvWare/wvWare')" />
<xsl:variable name="is-ppt" select="viv:test($url, '\.pp[st]$|\.pp[st]#', 'cregex')" />
<xsl:variable name="is-excel" select="$generator/@content = 'xlhtml'" />
<xsl:variable name="bad-title" select="$is-pdf or $is-doc or $is-ppt" />

<!-- main match -->

<xsl:template match="/">
  <document>
    <xsl:variable name="ver60" select="viv:vivisimo-version-is-newer-than('5.6-2')"/>
    <xsl:variable name="ignore-bots"></xsl:variable>

    <xsl:if test="$ver60 and ($ignore-bots or not(//meta[@name='robots' and (contains(@content, 'nofollow') or contains(@content, 'none'))]))">
      <xsl:call-template name="extract-links" />
    </xsl:if>
    <xsl:if test="not($ver60) or ($ignore-bots or not(//meta[@name='robots' and (contains(@content, 'noindex') or contains(@content, 'none'))]))">
      <xsl:call-template name="select-title" />
      <xsl:call-template name="process-meta" />
      <xsl:variable name="body" select="/*"/>

      <xsl:variable name="keep-mode" select="not($is-pdf or $is-doc or $is-ppt or $is-excel) and /*/*[@before-keep or @after-keep][1]"/>
      <xsl:if test="$keep-mode">
        <content name="pre-snippet" weight="0.1" output-action="summarize">
          <xsl:apply-templates select="viv:if-else($body, $body, /*)" 
           mode="x"
          >
            <xsl:with-param name="keep" select="1"/>
          </xsl:apply-templates>
        </content>
      </xsl:if>

      <content name="snippet" weight="1" output-action="summarize">
        <xsl:apply-templates select="viv:if-else($body, $body, *|text())" mode="x" >
          <xsl:with-param name="keep" select="viv:if-else($keep-mode, 2, 0)"/>
        </xsl:apply-templates>
      </content>

      <xsl:if test="$keep-mode">
        <content name="post-snippet" weight="0.1" output-action="summarize">
          <xsl:apply-templates select="viv:if-else($body, $body, *|text())" 
           mode="x"
          >
            <xsl:with-param name="keep" select="3"/>
          </xsl:apply-templates>
        </content>
      </xsl:if>
    </xsl:if>
  </document>
</xsl:template>

<xsl:template match="text()" />

<!-- Meta tag handling -->

<xsl:template name="process-meta">
  <xsl:if test="$meta-names">
    <xsl:apply-templates select="/*/head//meta" mode="metas"/>
  </xsl:if>
</xsl:template>

<xsl:template match="meta" mode="metas">
  <xsl:variable name="n" select="viv:str-to-lowercase(normalize-space(@name))"/>
  <xsl:variable name="t" select="normalize-space(@content)" />

  <xsl:if test=
   "$t and $t != '' and $n and viv:test($n, $meta-names, 'wc-set')"
  >
    <content name="{$n}" action="{$meta-action}"
      weight="{1}"
    >
      <xsl:value-of select="$t" />
    </content>
  </xsl:if>
</xsl:template>

<!-- Link extraction -->
<xsl:template name="extract-links">
  <xsl:apply-templates select="//a/@href" mode="extract-links" />
  <xsl:apply-templates select="//frame/@src" mode="extract-links" />
  <xsl:apply-templates select="//area/@href" mode="extract-links" />
  <xsl:apply-templates select="//embed/@src" mode="extract-links" />
  <xsl:apply-templates select="//iframe/@src" mode="extract-links" /> 
  <xsl:apply-templates select="//meta[@http-equiv]" mode="equiv-extract-links" />
</xsl:template>

<xsl:template match="@*" mode="extract-links">
  <xsl:variable name="extra-crawl-url">
    <crawl-url obey-no-follow="obey-no-follow"/>
  </xsl:variable>
  <xsl:value-of select="viv:crawl-enqueue-url(viv:url-resolve-base(normalize-space(.), $crawl-url-url), $extra-crawl-url)"/>
</xsl:template>

<xsl:template match="*" mode="equiv-extract-links">
  <xsl:variable name="extra-crawl-url">
    <crawl-url obey-no-follow="obey-no-follow"/>
  </xsl:variable>

  <xsl:if test="@http-equiv = 'refresh'">
    <xsl:variable name="content" select="@content"/>
    <xsl:variable name="urlpart" select="substring-after($content, ';')"/>
  
    <xsl:if test="starts-with($urlpart, 'url=')">
      <xsl:variable name="url" select="substring($urlpart, 4)"/>
    
      <xsl:value-of select="viv:crawl-enqueue-url(viv:url-resolve-base(normalize-space($url), $crawl-url-url), $extra-crawl-url)"/>
    </xsl:if>
  </xsl:if>
</xsl:template>


<!-- Title extraction -->

<xsl:template name="select-title">
  <xsl:variable name="t0" select="//title[normalize-space(.) != '']" />
  <!-- check if user xpath was successful, if not, fall back to default expression -->
  <xsl:variable name="t1" select="viv:if-else(string-length($t0) &gt; 0,$t0,//title[normalize-space(.) != ''])" />
  <xsl:variable name="t" select="viv:replace(viv:replace($t1, '^Microsoft Word - ', ''), '\.doc$', '')"/>

  <xsl:choose>
    <xsl:when test="$is-excel">
      <xsl:variable name="title"
        select="normalize-space(viv:concat(//h1[1]//text(), ' '))"
      />
      <xsl:if test="not(viv:test($title, '^Sheet[1-9][0-9]*$', 'regex'))">
        <content name="title" output-action="bold" weight="3">
          <xsl:value-of select="$title"/>
        </content>
      </xsl:if>
    </xsl:when>
    <xsl:when test="$bad-title">
      <xsl:call-template name="conditional-title-extractor">
        <xsl:with-param name="title" select="$t"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$t">
      <content name="title" output-action="bold" weight="3">
        <xsl:value-of select="$t"/>
      </content>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template name="conditional-title-extractor">
  <xsl:param name="title" select="//title" />

  <xsl:variable name="spans" select="//span" />
  <xsl:variable name="t-title" select="str:tokenize($title)" />

  <xsl:choose>
    <xsl:when test="string-length(normalize-space($title)) > 3">
      <xsl:call-template name="find-title-words">
        <xsl:with-param name="spans" select="$spans[position() &lt;= 100]" />
        <xsl:with-param name="title" select="$title" />
        <xsl:with-param name="t-title" select="$t-title" />
        <xsl:with-param name="pos" select="1" />
        <xsl:with-param name="may-miss" select="floor(count($t-title) div 4)" />
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$spans">
      <xsl:call-template name="generate-title">
        <xsl:with-param name="spans" select="$spans[position() &lt;= 100]" />
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template name="find-title-words">
  <xsl:param name="spans" />
  <xsl:param name="title" />
  <xsl:param name="t-title" />
  <xsl:param name="pos" />
  <xsl:param name="may-miss" />

  <xsl:choose>
    <xsl:when test="$pos > 0 and $pos > count($t-title)">
      <!-- found all title words, keep this title -->
      <content name="title" output-action="bold" weight="3">
        <xsl:value-of select="$title" />
      </content>
    </xsl:when>
    <xsl:when test="$pos &lt;= count($t-title) and $spans[viv:test(., concat('*', viv:replace($t-title[position() = $pos], '[[:punct:]]', '', 'g'), '*'), 'wc')]">
      <!-- found this title word, look for the next one -->
      <xsl:call-template name="find-title-words">
        <xsl:with-param name="spans" select="$spans" />
        <xsl:with-param name="title" select="$title" />
        <xsl:with-param name="t-title" select="$t-title" />
        <xsl:with-param name="pos" select="$pos + 1" />
        <xsl:with-param name="may-miss" select="$may-miss" />
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$may-miss > 0">
      <xsl:call-template name="find-title-words">
        <xsl:with-param name="spans" select="$spans" />
        <xsl:with-param name="title" select="$title" />
        <xsl:with-param name="t-title" select="$t-title" />
        <xsl:with-param name="pos" select="$pos + 1" />
        <xsl:with-param name="may-miss" select="$may-miss - 1" />
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <!-- no match for this word, generate a title -->
      <xsl:call-template name="generate-title">
        <xsl:with-param name="spans" select="$spans" />
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="generate-title">
  <xsl:param name="spans" />

  <content name="title" output-action="bold" weight="3">
    <xsl:choose>
      <xsl:when test="$is-pdf">
        <xsl:call-template name="pdf-title-extractor">
          <xsl:with-param name="spans" select="$spans" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$is-doc">
        <xsl:call-template name="doc-title-extractor">
          <xsl:with-param name="spans" select="$spans" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$is-ppt">
        <xsl:call-template name="doc-title-extractor">
          <xsl:with-param name="spans" select="$spans[position() &lt;= 10]" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </content>
</xsl:template>

<!-- DOC/PPT title extractor -->

<xsl:template name="doc-title-extractor">
  <xsl:param name="spans" />

  <xsl:variable name="sizes-str">
    <xsl:apply-templates select="$spans" mode="doc-emit-sizes">
      <xsl:sort select="number(substring-before(substring-after(@style, 'font-size: '), 'pt'))" data-type="number" order="descending" />
    </xsl:apply-templates>
  </xsl:variable>

  <xsl:variable name="sizes" select="str:tokenize($sizes-str)" />

  <xsl:call-template name="doc-title-size">
    <xsl:with-param name="spans" select="$spans" />
    <xsl:with-param name="sizes" select="$sizes" />
    <xsl:with-param name="pos" select="1" />
  </xsl:call-template>
</xsl:template>

<xsl:template name="doc-title-size">
  <xsl:param name="spans" />
  <xsl:param name="sizes" />
  <xsl:param name="pos" />

  <xsl:variable name="pt" select="$sizes[position() = $pos]" />
  <xsl:if test="$pos &lt;= count($sizes)">
    <xsl:choose>
      <xsl:when test="$pos = 1 or $pt != $sizes[position() = $pos - 1]">

        <xsl:variable name="positions-str">
          <xsl:apply-templates select="$spans" mode="doc-positions">
            <xsl:with-param name="pt" select="$pt" />
          </xsl:apply-templates>
        </xsl:variable>
        <xsl:variable name="positions" select="str:tokenize($positions-str)" />
        <xsl:variable name="position0" select="$positions[1]" />
        <xsl:variable name="s" select="$spans[substring-before(substring-after(@style, 'font-size: '), 'pt') = $pt and position() &lt;= $position0 + 10]" />

        <xsl:choose>
          <xsl:when test="$s//text()[string-length(normalize-space(.)) >= 5]">
            <xsl:call-template name="output-title-strings">
              <xsl:with-param name="text" select="$s" />
              <xsl:with-param name="pos" select="1" />
            </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="doc-title-size">
              <xsl:with-param name="spans" select="$spans" />
              <xsl:with-param name="sizes" select="$sizes" />
              <xsl:with-param name="pos" select="$pos + 1" />
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="doc-title-size">
          <xsl:with-param name="spans" select="$spans" />
          <xsl:with-param name="sizes" select="$sizes" />
          <xsl:with-param name="pos" select="$pos + 1" />
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template>

<xsl:template match="*" mode="doc-positions">
  <xsl:param name="pt" />
  <xsl:if test="substring-before(substring-after(@style, 'font-size: '), 'pt') = $pt">
    <xsl:value-of select="position()" />
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template>

<xsl:template mode="doc-emit-sizes" match="*">
  <xsl:value-of select="substring-before(substring-after(@style, 'font-size: '), 'pt')" /><xsl:text> </xsl:text>
</xsl:template>

<!-- PDF title extractor -->

<xsl:template name="pdf-title-extractor">
  <xsl:param name="spans" />

  <!-- make sure we don't try to extract a title from a blank page,
       look for pages that have at least one div on them.
    -->
  <xsl:variable name="pages" select="/*/*/div[div]" />
  <xsl:if test="$pages">
    <xsl:variable name="css" select="str:tokenize(viv:replace(viv:replace($pages[1]/style/comment(),'\{[^}]*font-size: *', ',', 'g'),'px[^}]*} *', '', 'g'), '&#10;')" />

    <xsl:variable name="biggest-str">
      <xsl:apply-templates select="$css" mode="strip-tags">
        <xsl:sort select="number(substring-after(text(), ','))" data-type="number" order="descending" />
      </xsl:apply-templates>
    </xsl:variable>

    <xsl:variable name="biggest" select="str:tokenize($biggest-str, ' ')" />
    <xsl:call-template name="pdf-title-size">
      <xsl:with-param name="sizes" select="$biggest" />
      <xsl:with-param name="pos" select="1" />
      <xsl:with-param name="spans" select="$spans" />
    </xsl:call-template>
  </xsl:if>
</xsl:template>

<xsl:template name="pdf-title-size">
  <xsl:param name="sizes" />
  <xsl:param name="pos" />
  <xsl:param name="spans" />

  <xsl:variable name="this" select="$sizes[position() = $pos]" />
  <xsl:variable name="size" select="substring-after($this, ',')" />
  <xsl:variable name="classes" select="$sizes[substring-after(., ',') = $size]" />

  <xsl:variable name="class-condition">
    false()
    <xsl:for-each select="$classes">
      or @class = '<xsl:value-of select="substring-after(substring-before(., ','), '.')" />'
    </xsl:for-each>
  </xsl:variable>

  <xsl:variable name="positions-str">
    <xsl:apply-templates select="$spans" mode="pdf-positions">
      <xsl:with-param name="class-condition" select="$class-condition" />
    </xsl:apply-templates>
  </xsl:variable>
  <xsl:variable name="positions" select="str:tokenize($positions-str)" />
  <xsl:variable name="position0" select="$positions[1]" />
  <xsl:variable name="s" select="dyn:evaluate(concat('$spans[position() &lt;= $position0 + 10 and (', $class-condition, ')]'))" />

  <xsl:choose>
    <xsl:when test="count($classes) = 0">
      <!-- will go into an infinite loop doing nothing -->
    </xsl:when>
    <xsl:when test="not(str:split(viv:concat($s//text()))[string-length(text())
> 1])">
      <xsl:call-template name="pdf-title-size">
        <xsl:with-param name="sizes" select="$sizes" />
        <xsl:with-param name="pos" select="$pos + count($classes)" />
        <xsl:with-param name="spans" select="$spans" />
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$s//text()[string-length(normalize-space(.)) >= 5]">
      <xsl:call-template name="output-title-strings">
        <xsl:with-param name="text" select="$s" />
        <xsl:with-param name="pos" select="1" />
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$classes">
      <xsl:call-template name="pdf-title-size">
        <xsl:with-param name="sizes" select="$sizes" />
        <xsl:with-param name="pos" select="$pos + count($classes)" />
        <xsl:with-param name="spans" select="$spans" />
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template match="*" mode="pdf-positions">
  <xsl:param name="class-condition" />
  <xsl:if test="dyn:evaluate($class-condition)">
    <xsl:value-of select="position()" />
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template>

<xsl:template name="output-title-strings">
  <xsl:param name="text" />
  <xsl:param name="pos" />
  <xsl:param name="limit" select="viv:if-else($is-ppt, 1, 100)" />
  <xsl:param name="bytes-output" select="0" />
  <xsl:param name="last-s" select="''" />

  <xsl:variable name="s">
    <xsl:for-each select="$text[position() = $pos]//text()">
      <xsl:value-of select="normalize-space(.)" />
      <xsl:text> </xsl:text>
    </xsl:for-each>
  </xsl:variable>

  <xsl:if test="string-length($s) &lt;= $limit or  5*$bytes-output &lt; $limit">

    <xsl:variable name="display-s">
      <xsl:if test="$s != $last-s">
        <xsl:value-of select="$s" />
      </xsl:if>
    </xsl:variable>

    <xsl:value-of select="$display-s" />

    <xsl:if test="$pos &lt; count($text)">
      <xsl:call-template name="output-title-strings">
        <xsl:with-param name="text" select="$text" />
        <xsl:with-param name="pos" select="$pos + 1" />
        <xsl:with-param name="limit" select="$limit - string-length($display-s)" />
        <xsl:with-param name="bytes-output" select="$bytes-output + string-length($display-s)" />
        <xsl:with-param name="last-s" select="$s" />
      </xsl:call-template>
    </xsl:if>
  </xsl:if>
</xsl:template>

<xsl:template match="text()" mode="strip-tags">
  <xsl:value-of select="." /><xsl:text> </xsl:text>
</xsl:template>

<xsl:template mode="x" match="*">
  <xsl:param name="keep"/>
  <xsl:if test="@alt">
    <xsl:apply-templates select="." mode="check-alt">
      <xsl:with-param name="keep" select="$keep"/>
    </xsl:apply-templates>
  </xsl:if>
  <xsl:text> </xsl:text>
  <xsl:apply-templates mode="x">
    <xsl:with-param name="keep" select="$keep"/>
  </xsl:apply-templates>
  <xsl:text> </xsl:text>
</xsl:template>

<xsl:template mode="x" match="font|span|div|td|a|h1|h2|h3|h4|h5|b|p|br|hr|li|option">
  <xsl:param name="keep"/>
  <xsl:if test="$keep = 0 or ($keep = 1 and @before-keep) or ($keep = 2 and @keep) or ($keep = 3 and @after-keep)">
    <xsl:if test="@alt">
      <xsl:apply-templates select="." mode="check-alt"/>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="(name() = 'br' and not($is-pdf)) or name() = 'hr' or name() = 'p'">
        <xsl:apply-templates mode="show-tag" select=".">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:when test="true() or text()[string-length(.) > 10 or normalize-space(.) != '']">
        <xsl:apply-templates mode="show-tag" select=".">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="x">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template>

<xsl:template mode="x" match="title|head|meta|script|style">
  <xsl:text> </xsl:text>
</xsl:template>


<xsl:template mode="show-tag" match="*">
  <xsl:param name="keep"/>

  <xsl:variable name="keeping" select="
      $keep = 0 or 
      (
        ( $keep = 1 and @before-keep ) or
        ( $keep = 3 and @after-keep   ) or
        ( $keep = 2 and not(@before-keep or @after-keep) )
      )
  "/>

    <xsl:if test="@alt and $keeping">
      <xsl:apply-templates select="." mode="check-alt"/>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="name() = 'span' and $is-doc">
        <!-- spans are purely font information for word documents, don't keep
             them. -->
        <xsl:apply-templates mode="x">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:when test="node()">
        <xsl:if test="$keeping">
          <xsl:value-of select="concat('&lt;', name(), '>')"/>
        </xsl:if>
        <xsl:apply-templates mode="x">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
        <xsl:if test="$keeping">
          <xsl:value-of select="concat('&lt;/', name(), '>')"/>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="$keeping">
          <xsl:value-of select="concat('&lt;', name(), '/>')"/>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>

</xsl:template>

<xsl:template mode="x" match="@*"/>

<!-- Otherwise, print the text.  Remove extra white space to make it
     easier to read.
  -->

<xsl:template mode="x" match="text()">
  <xsl:param name="keep"/>

  <xsl:if test="
      $keep = 0 or 
      (
        ( $keep = 1 and ../@before-keep ) or
        ( $keep = 3 and ../@after-keep   ) or
        ( $keep = 2 and not(../@before-keep or ../@after-keep) )
      )
  ">
   <xsl:value-of select="viv:node-to-str(.)" />
  </xsl:if>
</xsl:template>

<xsl:template mode="check-alt" match="a|img">
  <xsl:if test="$include-alts and @alt and normalize-space(@alt) != ''">
    <xsl:text> </xsl:text>
    <xsl:value-of select="viv:node-to-str(exsl:node-set(string(@alt)))"/>
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template>


]]></parser></converter><converter type-in="text/plain" type-out="application/vxml-unnormalized" elt-id="2100" timing-name="Text to XML"><macro name="vse-converter-text-content"><add-content type="text"><attribute name="name"><value-of-var name="name" /></attribute><if-var name="action"><attribute name="action"><value-of-var name="action" /></attribute></if-var><if-var name="output-action"><attribute name="output-action"><value-of-var name="output-action" /></attribute></if-var><if-var name="weight"><attribute name="weight"><value-of-var name="weight" /></attribute></if-var></add-content></macro><parser name="text2vxml"><match token="^" goto="start"><add-document /></match><state name="start"><match token="..*" goto="more"><add-content type="text" name="snippet" /></match></state><state name="more"><match token="..*" goto="more"><prepend token=" " /><add-content type="text" name="snippet" /></match></state></parser></converter><converter type-in="unknown" type-out="application/dbf" elt-id="2102"><converter-test how="wc-set" what="path" elt-id="2103"><![CDATA[*.dbf]]></converter-test></converter><converter type-in="application/dbf" type-out="text/csv" elt-id="2104" timing-name="DBF to CSV"><converter-execute><![CDATA[dbf --csv - %source_file | %bin/../iso2utf]]></converter-execute></converter><converter type-in="text/csv" type-out="application/vxml-unnormalized" elt-id="2106" timing-name="CSV to XML"><converter-execute><![CDATA[%bin/csv2vxml %source_file]]></converter-execute></converter><converter type-in="text/xml" type-out="application/vxml-unnormalized" elt-id="2108" timing-name="XML to Vivisimo XML"><parser type="xsl"><![CDATA[<xsl:template match="/">
  <document>
    <content name="snippet" output-action="summarize">
      <xsl:apply-templates select="*" mode="xml-to-plain-text" />
    </content>
  </document>
</xsl:template>

<xsl:template match="*" mode="xml-to-plain-text">
  <xsl:text><![CDATA[<]]]><![CDATA[]></xsl:text>
  <xsl:value-of select="name()" />
  <xsl:text> </xsl:text>
  <xsl:choose>
    <xsl:when test="text()|*|comment()">
      <xsl:text><![CDATA[>]]]><![CDATA[]></xsl:text>
      <xsl:apply-templates select="text()|*|comment()" mode="xml-to-plain-text" />
      <xsl:text><![CDATA[</]]]><![CDATA[]></xsl:text>
      <xsl:value-of select="name()" />
      <xsl:text><![CDATA[>]]]><![CDATA[]></xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text><![CDATA[/>]]]><![CDATA[]></xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>]]></parser></converter><converter type-in="application/vxml-unnormalized" type-out="application/vxml-unnormalized" elt-id="2110" timing-name="Normalization"><parser type="xsl"><![CDATA[
  <xsl:variable name="max-title-length"><![CDATA[120]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="date-bias-what"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="date-bias-xpath"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="last-modified"><![CDATA[true]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="last-modified-weight"><![CDATA[-1]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="crawled-date"><![CDATA[true]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="crawled-date-weight"><![CDATA[-1]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-detection"><![CDATA[true]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-contents"><![CDATA[title|snippet]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-content"><![CDATA[language]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-bytes"><![CDATA[50000]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="static-summary-names"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="static-summary-bytes"><![CDATA[]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <vce>
    <xsl:apply-templates/>
  </vce>
</xsl:template>

<xsl:template match="vce">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates/>
  </xsl:copy>
</xsl:template>

<xsl:template match="document">
  <xsl:copy>
    <xsl:if test="viv:vivisimo-version() = '5.5-6'">
      <xsl:if test="viv:current-node()/@warning">
        <!-- bug in 5.5-6 that causes the warning attribute from the crawl-url
             node to the document when indexed. Make sure it doesn't end up in
             there.
          -->
        <xsl:attribute name="warning"/>
      </xsl:if>
    </xsl:if>
    <xsl:apply-templates select="@*[not(name() = $date-bias-what)]" />
    <xsl:apply-templates mode="document-attributes" select="."/>
    <xsl:call-template name="handle-date-bias" />
    <xsl:call-template name="output-dates" />
    <xsl:if test="$language-detection and $language-detection = 'true' and function-available('viv:classify-language')">
      <xsl:apply-templates mode="language" select="."/>
    </xsl:if>
    <xsl:apply-templates select="*"/>
    <xsl:apply-templates mode="document" select="." />
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:choose>
    <xsl:when test="$static-summary-names and viv:test(@name, $static-summary-names, 'wc-set')">
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:attribute name="action">index-only</xsl:attribute>
        <xsl:apply-templates mode="content-attributes" select="."/>
        <xsl:copy-of select="text()"/>
      </xsl:copy>
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:attribute name="weight">-1</xsl:attribute>
        <xsl:apply-templates mode="content-attributes" select="."/>
        <xsl:call-template name="chop">
          <xsl:with-param name="text" select="viv:if-else(@type = 'text', ., viv:replace(., '&lt;[^>]*>', ' ', 'g'))"/>
          <xsl:with-param name="max-length" select="viv:evaluate($static-summary-bytes)"/>
        </xsl:call-template>
      </xsl:copy>
    </xsl:when>
<!--<xsl:when test="$normalize-spaces and $normalize-spaces = 'true'">
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:copy-of select="normalize-space(.)"/>
      </xsl:copy>
    </xsl:when>
-->
    <xsl:otherwise>
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:apply-templates mode="content-attributes" select="."/>
        <xsl:copy-of select="text()"/>
      </xsl:copy>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:apply-templates mode="content" select="."/>
</xsl:template>

<xsl:template match="text()|comment()|@*">
  <xsl:copy />
</xsl:template>

<!-- *******************************************
               Language detection
     ******************************************* -->

<xsl:template mode="language" match="document">
  <xsl:variable name="c" select="content[viv:test(@name, $language-contents, 'wc-set')]"/>
  <xsl:variable name="html">
    <xsl:call-template name="language-text">
      <xsl:with-param name="c" select="$c[not(@type) or @type != 'text']"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="text">
    <xsl:call-template name="language-text">
      <xsl:with-param name="c" select="$c[@type = 'text']"/>
      <xsl:with-param name="len" select="string-length($html)"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="l" select="viv:classify-language($html, 'html', $text, 'text')"/>
  <content name="{$language-content}" weight="0" action="none">
    <xsl:value-of select="viv:if-else($l and $l != '', $l, 'unknown')"/>
  </content>
</xsl:template>

<xsl:template name="language-text">
  <xsl:param name="c" />
  <xsl:param name="i" select="1" />
  <xsl:param name="len" select="0" />

  <xsl:choose>
    <xsl:when test="$i > count($c)"/>
    <xsl:when test="$language-bytes &lt; 0">
      <xsl:value-of select="$c[$i]"/>
      <xsl:call-template name="language-text">
        <xsl:with-param name="c" select="$c"/>
        <xsl:with-param name="i" select="$i + 1"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$len >= $language-bytes"/>
    <xsl:otherwise>
      <xsl:variable name="l" select="string-length($c[$i])"/>
      <xsl:value-of select="substring($c[$i], 1, $language-bytes - $len)"/>
      <xsl:call-template name="language-text">
        <xsl:with-param name="c" select="$c"/>
        <xsl:with-param name="i" select="$i + 1"/>
        <xsl:with-param name="len" select="$len + $l"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<!-- *******************************************
               Date bias
     ******************************************* -->

<xsl:template name="handle-date-bias">
  <xsl:variable name="at">
    <xsl:choose>
      <xsl:when test="$date-bias-xpath and number(dyn:evaluate($date-bias-xpath)) > 0">
        <xsl:value-of select="dyn:evaluate($date-bias-xpath)"/>
      </xsl:when>
      <xsl:when test="$crawl-url-last-modified and number($crawl-url-last-modified) > 0">
        <xsl:value-of select="$crawl-url-last-modified" />
      </xsl:when>
      <xsl:when test="$crawl-url-at and number($crawl-url-at) > 0">
        <xsl:value-of select="$crawl-url-at" />
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:if test="$date-bias-what != '' and $at and number($at) > 0">
    <xsl:attribute name="{$date-bias-what}">
      <xsl:value-of select="viv:if-else($date-bias-what != 'la-score', 1, 0) + (1 div ((date:seconds() - $at) div (60*60*24) + 1.5) * viv:if-else(@*[name() = $date-bias-what], @*[name() = $date-bias-what], 1))" />
    </xsl:attribute>
  </xsl:if>
</xsl:template>

<!-- *******************************************
               Output dates
     ******************************************* -->

<xsl:template name="output-dates">
  <xsl:if test="$crawl-url-last-modified and number($crawl-url-last-modified) > 0 and $last-modified and $last-modified = 'true' and not(content[@name='last-modified'])">
    <content name="last-modified" action="none" weight="{$last-modified-weight}">
      <xsl:call-template name="print-date">
        <xsl:with-param name="secs" select="$crawl-url-last-modified" />
      </xsl:call-template>
    </content>
  </xsl:if>
  <xsl:if test="$crawled-date and $crawled-date = 'true' and $crawl-url-at and $crawl-url-at != '' and number($crawl-url-at) > 0">
    <content name="crawled-date" action="none" weight="{$crawled-date-weight}">
      <xsl:call-template name="print-date">
        <xsl:with-param name="secs" select="$crawl-url-at" />
      </xsl:call-template>
    </content>
  </xsl:if>
</xsl:template>

<xsl:template name="print-date">
  <xsl:param name="secs" />
  <xsl:attribute name="seconds">
    <xsl:value-of select="$secs"/>
  </xsl:attribute>
  <xsl:param name="duration" select="concat('P0Y0M0DT0H0M', $secs, 'S')" />
  <xsl:variable name="d" select="date:add('1970-01-01T00:00:00Z', $duration)" />

  <xsl:value-of select="substring(date:month-name($d), 1, 3)" />
  <xsl:text> </xsl:text>
  <xsl:value-of select="date:day-in-month($d)" />,
  <xsl:value-of select="date:year($d)" />
  <xsl:text> </xsl:text>
  <xsl:value-of select="format-number(date:hour-in-day($d), '00')" />
  <xsl:text>:</xsl:text>
  <xsl:value-of select="format-number(date:minute-in-hour($d), '00')" />
  <xsl:text>:</xsl:text>
  <xsl:value-of select="format-number(date:second-in-minute($d), '00')" />
  <xsl:text> GMT</xsl:text>
</xsl:template>

<!-- *******************************************
               Truncate long titles
     ******************************************* -->

<xsl:template match="content[@name='title' and $max-title-length > 0]">
  <xsl:copy>
    <xsl:apply-templates select="@*|comment()|*" />
    <xsl:call-template name="chop">
      <xsl:with-param name="text" select="." />
      <xsl:with-param name="max-length" select="$max-title-length" />
    </xsl:call-template>
  </xsl:copy>
  <xsl:apply-templates mode="content" select="."/>
</xsl:template>


<!-- Truncate strings -->

<xsl:template name="chop">
  <xsl:param name="text" />
  <xsl:param name="max-length" />

  <xsl:variable name="t" select="normalize-space($text)" />

  <xsl:choose>
    <xsl:when test="string-length($t) > $max-length">
      <xsl:variable name="t-hacked" select="substring($t, 1, $max-length)" />
      <xsl:value-of select="viv:replace($t-hacked, '[^[:space:],\.;:>]*$', '')" />
      <xsl:text>...</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$t" />
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<!-- Placeholders for the hooks -->

<xsl:template mode="document" match="*"/>
<xsl:template mode="document-attributes" match="*"/>
<xsl:template mode="content" match="*"/>
<xsl:template mode="content-attributes" match="*"/>

]]></parser></converter><converter type-in="application/vxml-unnormalized" type-out="application/vxml" elt-id="2112" /></converters></vse-config><vse-status version="6.0" which="live" token="Rwpf9A8McCdn" config-md5="24e43210f39d3015c35620c336d878dc"><crawler-status config-md5="24e43210f39d3015c35620c336d878dc" time="1191862276" elapsed="15" this-elapsed="15" host="all" n-input="1" n-output="1" n-errors="0" n-http-errors="0" n-http-location="0" n-filtered="0" n-robots="0" conversion-time="53" n-sub="1" n-bytes="7996.000000" n-dl-bytes="7996.000000" converted-size="7996.000000" n-pending="0" n-redirect="0" n-duplicates="0" n-deleted="0" n-cache-complete="0" n-awaiting-index-input="0" n-awaiting-index-reply="0" complete="complete" idle="idle" final="final"><converter-timings total-ms="88"><converter-timing timing-name="Text to XML" n="1" ms="4" bytes-in="7996" bytes-out="7826" /><converter-timing timing-name="Guess content" n="1" ms="51" bytes-in="7996" bytes-out="0" /><converter-timing timing-name="Binary file extensions (filter)" n-check="1" ms-check="0" bytes-in-check="84" /><converter-timing timing-name="Normalization" n="1" ms="30" bytes-in="7826" bytes-out="8182" /></converter-timings><crawl-hops-output><crawl-hop hop="0" n="1" /></crawl-hops-output><crawl-hops-input><crawl-hop hop="0" n="0" /></crawl-hops-input></crawler-status><vse-index-status identifier="Rwpf-QTJaSfI" slice="0" n-slices="1" version="williams2" start-time="1191862261" indexing-time="18" indexed-urls="1" indexed-datas="1" indexed-docs="1" indexed-contents="6" indexed-bytes="8657" error-datas="0" error-items="0" n-docs="1" max-docs="1" config-md5="24e43210f39d3015c35620c336d878dc" running-time="18" input-port="2816" input-token="Rwpf9QRwGSfI" channel-port="56383" channel-token="Rwpf9QRweSfI" idle="idle"><vse-serving port="14864" n-queries="1" n-cached-queries="0" n-pings="0" n-documents="1" n-no-documents="0" ms-queries="1" n-threads="2" n-idle-threads="2" /><vse-index-file name="viv_idx_QAj84T" fname="./viv_idx_QAj84T" type="index" size="33792" at="1191862269" n-docs="1" max-docs="1" min-docid="0" max-docid="0"><vse-index-content name="doc#" n="1" words="0" /><vse-index-content name="last-modified" n="1" words="1" /><vse-index-content name="host" n="1" words="0" /><vse-index-content name="acl#" n="3" words="3420" /><vse-index-content name="snippet" n="1" words="1118" /><vse-index-content name="url" n="1" words="14" /><vse-index-content name="url#" n="1" words="1141" /><vse-index-content name="crawled-date" n="1" words="1" /><vse-index-content name="language" n="1" words="1" /></vse-index-file><vse-index-cache-statuses block-size="8192"><vse-index-cache-status fname="./viv_idx_QAj84T" core-size="512"><vse-index-cache-status-segment i="0" size="8192" allocated="8192" last="0" /><vse-index-cache-status-segment i="1" size="16384" allocated="16384" last="0" /><vse-index-cache-status-segment i="2" size="0" allocated="0" last="0" /></vse-index-cache-status></vse-index-cache-statuses><vse-index-merge-status n-segments="1" n-indices="0" start="1191862269" to-read="32768" read="32768" written="24576" end="1191862269" total-ms="15" /><reconstructor-statuses ms="12" n-pending="0"><reconstructor-status n-to-do="1" n-done="1" start="1191862269" end="1191862269" /><value-set-field name="last-modified" type="date" n-instances="1" data-bytes="5" meta-bytes="0" /></reconstructor-statuses><la-scores-statuses><la-scores-status start="1191862277" pct="0" end="1191862277" /></la-scores-statuses><vse-index-builder-status elapsed="2.577" n-urls="0" n-segments="0" ms="10" /></vse-index-status></vse-status><vse-run which="live"><vse-index><run pid="10184" port="57455" path="/srv/www/htdocs/vivisimo//data/collections/samba-one-dottxt/crawl0" cmd="/srv/www/htdocs/vivisimo/bin/services/indexer-service" /></vse-index></vse-run><hidden><vse-meta name="samba-one-dottxt" creator="gary_testing" create-time="1184272390" elt-id="1" max-elt-id="1" modified="1191862260" which="live" push-toggle="push-toggle" /></hidden><vse-meta name="samba-one-dottxt" creator="gary_testing" create-time="1184272390" elt-id="1" max-elt-id="1" modified="1191862260" push-toggle="push-toggle"><proto-section label="Directories" section="Directories"><declare tag="vse-meta-info" name="live-crawl-dir" type="directory"><label><![CDATA[Live data]]></label><description>
      </description></declare><declare tag="vse-meta-info" name="staging-crawl-dir" type="directory"><label><![CDATA[Staging data]]></label><description>
      </description></declare><declare tag="vse-meta-info" name="cache-dir" type="string"><label><![CDATA[Result cache]]></label><description><![CDATA[
        The directory in which to store result cache files. By
        default, the result cache is stored in the
        ]]><incode><![CDATA[data/]]></incode><i><![CDATA[collection-name]]></i><incode><![CDATA[/cache]]></incode><![CDATA[
        subdirectory of your installation directory.
      ]]></description></declare></proto-section><proto-section label="Advanced collection features" section="Advanced_collection_features"><declare tag="vse-meta-info" name="refresh" type="enum" enum-values="partial|full"><label><![CDATA[Fast refresh]]></label><description><![CDATA[
        This refresh mode requires that certain conditions be true
        regarding the equivalance of keys and urls in the crawl.  If
        these conditions are met, this mode can be used to refresh a
		collection much more quickly.  A ]]><i><![CDATA[partial]]></i><![CDATA[ refresh
        should be used if you can generate a set of deletes manually
        (for example, using a database).  A ]]><i><![CDATA[full]]></i><![CDATA[ refresh should
        be used for filesystem crawling or other crawls in which the
        only way to identify deletes is to test each file.
      ]]></description></declare><declare tag="vse-meta-info" name="enable-remote" type="flag"><label><![CDATA[Enable remote collections]]></label><description><![CDATA[
        Remote collections allow this collection's data, configuration and
        state to be pushed to remote machines to provide load balancing,
        fault-tolerance and backup.  Enabling this option will allow you
        to edit the remote configuration in the admin tool.
      ]]></description></declare></proto-section><proto-section label="General collection information" section="General_collection_information"><declare tag="vse-meta-info" name="maintainers" type="user-set" user-set-permission="admin-user" enum-values="gary_testing|williams"><label><![CDATA[Maintainers]]></label></declare><declare tag="vse-meta-info" name="desc" type="xml" dont-escape="dont-escape" two-rows="two-rows"><label><![CDATA[Description]]></label></declare></proto-section></vse-meta></vse-collection><test-it-values no-comment="no-comment"><proto-section><declare name="test-url" type="url" required="required"><label><![CDATA[URL]]></label><description><![CDATA[
	  A URL to test using the converter rules currently configured for 
	  this search collection.
	]]></description></declare><declare name="test-ct" type="string"><label><![CDATA[Content type]]></label><description><![CDATA[
	Override any content type inferred from the search engine and
	begin conversion at this content-type.
      ]]></description></declare><declare name="test-force" type="flag"><label><![CDATA[Force a recrawl]]></label><description><![CDATA[
	By default a cached copy of the URL will be used (if it exists). 
	Forcing a recrawl will ignore any previously cached copy.
      ]]></description></declare><declare name="enable-debug" type="flag"><label><![CDATA[Enable debugging]]></label><description><![CDATA[
	Enabling debugging will create a debug session that you can view
	in the management session (there will also be a link to the session
	in the test output).
      ]]></description></declare><declare name="force-allow" type="flag"><label><![CDATA[Force allow]]></label><description><![CDATA[
	Add a crawler option to allow the URL to be crawled.
      ]]></description></declare><declare name="no-limit-enqueued" type="flag"><label><![CDATA[Enqueue all URLs]]></label><description><![CDATA[
	During testing, the Java-based connectors limit the number of
	URLs that can be enqueued from a single URL. This can improve the
	speed of testing a URL that enqueues many other URLs. Enqueueing all
	URLs will show all enqueued URLs.
      ]]></description></declare></proto-section></test-it-values></interaction>