<?xml version="1.0" encoding="UTF-8" standalone="yes" ?><vse-collection id="RiN-1gwnzklh">


<vse-run><vse-remote-service /><crawler /><vse-index /></vse-run><vse-status which="live" identifier="RiUhAAZ0dV0v"><crawler-status time="1176838398" elapsed="86" this-elapsed="86" n-input="387" n-output="386" n-errors="1" n-http-errors="0" n-http-location="0" n-filtered="0" n-robots="0" conversion-time="1593" n-sub="386" n-bytes="353760" n-dl-bytes="353760" converted-size="209781" n-pending="0" n-redirect="0" n-duplicates="0" n-deleted="0" n-cache-complete="0" complete="complete"><converter-timings total-ms="1592"><converter-timing timing-name="Sharepoint Documents" n="385" ms="1551" bytes-in="447594" bytes-out="209750" /></converter-timings><crawl-hops-output><crawl-hop hop="0" n="38" /><crawl-hop hop="1" n="241" /><crawl-hop hop="2" n="58" /><crawl-hop hop="3" n="48" /><crawl-hop hop="4" n="1" /></crawl-hops-output><crawl-hops-input /></crawler-status><vse-index-status identifier="RiUhAAZ0dV0v" n-merge-idx="0" final-size="568832" start-time="1176838399" link-analysis-time="1" indexing-time="1" merging-time="1" link-analysis-pct="1" indexed-urls="386" uncrawled-urls="0" n-deletes="0" indexed-datas="386" indexed-docs="385" indexed-contents="2988" indexed-bytes="413147" error-datas="0" error-items="0" running-time="1" core-size="7680" docs-size="1540" fi-size="6620" word-blocks="31" text-blocks="498" content-blocks="18" block-size="1024" end-time="1176838400"><vse-index-merge-status n-to-merge="1" start="1176838400" n-merging="1" blocks-to-read="4" blocks-read="4" end="1176838400" /><vse-index-file name="viv_BjuMfM" gen="0" type="index" at="1176838400" max-docs="385" size="568832" n-docs="385" /><converter-timings total-ms="531"><converter-timing timing-name="Text to XML" n="1" ms="1" bytes-in="31" bytes-out="197" /><converter-timing timing-name="Normalization" n="386" ms="504" bytes-in="209947" bytes-out="279507" /></converter-timings><vse-index-content-name-status name="last-modified" n="386" words="2236" tag-bytes="22024" text-bytes="8967" n-acls="386" acl-bytes="12352" /><vse-index-content-name-status name="host" n="385" words="385" tag-bytes="18480" text-bytes="4620" n-acls="385" acl-bytes="12320" /><vse-index-content-name-status name="description" n="310" words="3834" tag-bytes="24490" text-bytes="21532" n-acls="310" acl-bytes="9920" /><vse-index-content-name-status name="snippet" n="28" words="737" tag-bytes="1415" text-bytes="4869" n-acls="28" acl-bytes="896" /><vse-index-content-name-status name="url" n="385" words="3504" tag-bytes="18095" text-bytes="25174" n-acls="385" acl-bytes="12320" /><vse-index-content-name-status name="crawled-date" n="386" words="386" tag-bytes="30108" text-bytes="10422" n-acls="386" acl-bytes="12352" /><vse-index-content-name-status name="author" n="385" words="770" tag-bytes="27335" text-bytes="10010" n-acls="385" acl-bytes="12320" /><vse-index-content-name-status name="language" n="386" words="386" tag-bytes="20072" text-bytes="2702" n-acls="386" acl-bytes="12352" /><vse-index-content-name-status name="title" n="337" words="575" tag-bytes="24601" text-bytes="4217" n-acls="337" acl-bytes="10784" /><value-set-field name="last-modified" type="date" n-values="0" meta-bytes="18" data-bytes="3474" /></vse-index-status></vse-status><vse-config elt-id="2025" max-elt-id="2114"><crawler elt-id="2026"><crawl-condition-when field="protocol"><crawl-pattern><![CDATA[http]]></crawl-pattern><crawl-condition-when field="host" how="wc-set"><crawl-pattern><![CDATA[192.168.0.27]]></crawl-pattern><crawl-condition-when field="path"><crawl-pattern><![CDATA[/*]]></crawl-pattern><curl-options><curl-option name="user-password"><![CDATA[VIVISIMO2003\Administrator:Baseball123]]></curl-option></curl-options></crawl-condition-when></crawl-condition-when></crawl-condition-when><crawl-urls><crawl-url url="sharepoint://192.168.0.27:9000/" /></crawl-urls><crawl-condition-when field="protocol"><crawl-pattern><![CDATA[sharepoint]]></crawl-pattern><crawl-condition-when field="host" how="wc-set"><crawl-pattern><![CDATA[192.168.0.27]]></crawl-pattern><crawl-condition-when field="user" how="wc-set"><crawl-pattern><![CDATA[*]]></crawl-pattern><crawl-condition-when field="path"><crawl-pattern><![CDATA[/*]]></crawl-pattern><curl-options><curl-option name="default-allow"><![CDATA[allow]]></curl-option><curl-option name="user-password"><![CDATA[VIVISIMO2003\Administrator:Baseball123]]></curl-option><crawl-extender-option name="sharepoint-version"><![CDATA[2003]]></crawl-extender-option></curl-options></crawl-condition-when></crawl-condition-when></crawl-condition-when></crawl-condition-when><crawl-extender protocol="sharepoint" exec="%java -classpath %classpath -Xmx160m -XX:+DisplayVMOutputToStderr -XX:+HeapDumpOnOutOfMemoryError -Djava.io.tmpdir='/usr/local/vivisimo-goulding2/tmp' com.vivisimo.connector.ConnectorRunner" dns="dns"><crawl-extender-option name="classname"><![CDATA[com.vivisimo.connector.SharepointConnector]]></crawl-extender-option></crawl-extender><crawl-condition-when field="query" how="wc-set"><crawl-pattern><![CDATA[N=A
N=D
M=A
M=D
S=A
S=D
D=A
D=D]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[N M S D]]></curl-option></curl-options></crawl-condition-when><crawl-may-not-have field="path"><crawl-pattern><![CDATA[*.aif
*.arc
*.aiff
*.asf
*.au
*.avi
*.bin
*.bmp
*.cab
*.class
*.dbx
*.dll
*.exe
*.fpt
*.gif
*.img
*.iso
*.jar
*.jpeg
*.jpg
*.kpg
*.lib
*.max
*.mdb
*.mp3
*.mp4
*.mpa
*.mpg
*.mpeg
*.mov
*.moov
*.msi
*.ns2
*.ns3
*.ns4
*.ocx
*.ogg
*.p65
*.pfc
*.png
*.psd
*.qt
*.qxd
*.ra
*.ram
*.rpm
*.rm
*.sea
*.so
*.smi
*.smil
*.swp
*.sys
*.tif
*.tiff
*.tmb
*.vsd
*.wav
*.wma
*.wmv
*.ymg
*.yps
~$*.doc
*/~$*.doc
*/Thumbs.db
]]></crawl-pattern></crawl-may-not-have><crawl-condition-when field="path"><crawl-pattern><![CDATA[*/bugzilla/*.cgi]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[bug_status email1 emailtype1 emailassigned_to1 emailreporter1 order]]></curl-option></curl-options><crawl-may-not-have field="path"><crawl-pattern><![CDATA[*/bugzilla/showdependencytree.cgi
*/bugzilla/long_list.cgi
*/bugzilla/show_activity.cgi
*/bugzilla/showdependencygraph.cgi]]></crawl-pattern></crawl-may-not-have></crawl-condition-when><crawl-may-not-have field="path"><crawl-pattern><![CDATA[/d[0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9](/[^/]*)?]]></crawl-pattern></crawl-may-not-have><crawl-may-not-have><crawl-pattern><![CDATA[*/webcalendar/view.asp*
*/webcalendar/seclogin.asp*
*/webcalendar/reg.asp*]]></crawl-pattern></crawl-may-not-have><crawl-may-not-have><crawl-pattern><![CDATA[*/webevent.cgi?*cmd=*cal=*
*/webevent.cgi?*cal=*cmd=* ]]></crawl-pattern></crawl-may-not-have><crawl-condition-when field="protocol" how="wc-set"><crawl-pattern><![CDATA[file
exec
smb]]></crawl-pattern><crawl-condition-when field="host" how="wc"><crawl-pattern><![CDATA[?*]]></crawl-pattern><curl-options><curl-option name="delay"><![CDATA[0]]></curl-option></curl-options></crawl-condition-when><crawl-condition-except field="host" how="wc"><crawl-pattern><![CDATA[?*]]></crawl-pattern><curl-options><curl-option name="delay"><![CDATA[0]]></curl-option></curl-options></crawl-condition-except></crawl-condition-when><crawl-condition-when field="url" how="cregex"><crawl-pattern><![CDATA[\.nsf(/[^/]*)?\?Open(View|Database)(&.*)?$]]></crawl-pattern><curl-options><curl-option name="case-normalize"><![CDATA[url]]></curl-option><curl-option name="remove-cgi-parameters"><![CDATA[Collapse Expand Count ExpandView Start]]></curl-option></curl-options><crawl-replace this="&amp;*$" that="&amp;start=1&amp;Count=10000&amp;ExpandView" /></crawl-condition-when><crawl-condition-when field="path" how="cregex"><crawl-pattern><![CDATA[\.nsf(/[^/]*)*/[a-f0-9]{32}?$]]></crawl-pattern><crawl-condition-when field="path" how="wc-set"><crawl-pattern><![CDATA[*/$file/*]]></crawl-pattern><curl-options><curl-option name="case-normalize"><![CDATA[url]]></curl-option></curl-options><crawl-replace this="\.[nN][Ss][Ff]/[a-fA-F0-9]{32}" that=".nsf/0" /></crawl-condition-when><crawl-condition-when field="query" how="wc-set"><crawl-pattern><![CDATA[OpenDocument
OpenDocument&*
]]></crawl-pattern><curl-options><curl-option name="case-normalize"><![CDATA[url]]></curl-option></curl-options><crawl-replace this="\.[nN][Ss][Ff]/[a-fA-F0-9]{32}" that=".nsf/0" /></crawl-condition-when><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[Collapse Expand Count ExpandView Start ExpandSection]]></curl-option></curl-options></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[*&sid=*]]></crawl-pattern><crawl-replace this="&amp;sid=[^&amp;]*" that="&amp;sid=0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[sid=*]]></crawl-pattern><crawl-replace this="\?sid=[^&amp;]*" that="?sid=0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[*&PHPSESSID=*]]></crawl-pattern><crawl-replace this="&amp;PHPSESSID=[^&amp;]*" that="&amp;PHPSESSID=0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[PHPSESSID=*]]></crawl-pattern><crawl-replace this="\?PHPSESSID=[^&amp;]*" that="?PHPSESSID=0" /></crawl-condition-when><crawl-condition-when field="path"><crawl-pattern><![CDATA[*;jsessionid=*]]></crawl-pattern><crawl-replace this="%3[bB]jsessionid%3[dD][^?]*" that="%3Bjsessionid%3D0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[*__VIEWSTATE=*]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[__VIEWSTATE]]></curl-option></curl-options></crawl-condition-when><crawl-may-not-have field="query"><crawl-pattern><![CDATA[*&MSCSProfile=*
MSCSProfile=*]]></crawl-pattern></crawl-may-not-have><crawl-condition-when field="port"><crawl-pattern><![CDATA[8765]]></crawl-pattern><curl-options /><crawl-may-not-have field="path"><crawl-pattern><![CDATA[query.html]]></crawl-pattern></crawl-may-not-have></crawl-condition-when><crawl-condition-when field="path"><crawl-pattern><![CDATA[*/wiki/*]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[action previous version]]></curl-option></curl-options></crawl-condition-when><crawl-condition-when field="path"><crawl-pattern><![CDATA[*/bugzilla/*.cgi]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[bug_status email1 emailtype1 emailassigned_to1 emailreporter1 order]]></curl-option></curl-options><crawl-may-not-have field="path"><crawl-pattern><![CDATA[*/bugzilla/showdependencytree.cgi
*/bugzilla/long_list.cgi
*/bugzilla/show_activity.cgi
*/bugzilla/showdependencygraph.cgi]]></crawl-pattern></crawl-may-not-have></crawl-condition-when></crawler><vse-index elt-id="2036"><vse-index-option name="output-contents" elt-id="2037"><![CDATA[title]]></vse-index-option><vse-index-option name="summarize-contents" elt-id="2038"><![CDATA[snippet]]></vse-index-option><vse-index-option name="fast-index" elt-id="2039"><![CDATA[last-modified|date]]></vse-index-option><vse-url-equivs name="vse-url-equivs" elt-id="2040"><vse-url-equiv old-prefix="smb://" new-prefix="file://///" elt-id="2041" /></vse-url-equivs></vse-index><converters elt-id="2042"><converter type-in="unknown" type-out="dead" elt-id="2043" timing-name="Binary file extensions (filter)"><converter-test what="url" how="wc-set"><![CDATA[*#*.aif
*#*.arc
*#*.aiff
*#*.asf
*#*.au
*#*.avi
*#*.bin
*#*.bmp
*#*.cab
*#*.class
*#*.dbx
*#*.dll
*#*.exe
*#*.fpt
*#*.gif
*#*.img
*#*.iso
*#*.jar
*#*.jpeg
*#*.jpg
*#*.kpg
*#*.lib
*#*.max
*#*.mdb
*#*.mp3
*#*.mp4
*#*.mpa
*#*.mpg
*#*.mpeg
*#*.mov
*#*.moov
*#*.msi
*#*.ns2
*#*.ns3
*#*.ns4
*#*.ocx
*#*.ogg
*#*.p65
*#*.pfc
*#*.png
*#*.psd
*#*.qt
*#*.qxd
*#*.ra
*#*.ram
*#*.rpm
*#*.rm
*#*.sea
*#*.so
*#*.smi
*#*.smil
*#*.swp
*#*.sys
*#*.tif
*#*.tiff
*#*.tmb
*#*.vsd
*#*.wav
*#*.wma
*#*.wmv
*#*.ymg
*#*.yps
*#~$*.doc
*#*/~$*.doc
*#*/Thumbs.db
]]></converter-test></converter><converter type-in="unknown" program="guess-content %source_file" timing-name="Guess content" elt-id="2045" /><converter type-in="application/ms-office" program="ms-guess %source_file" timing-name="Guess MS Office" elt-id="2046" /><converter type-in="unknown" type-out="text/plain" elt-id="2047"><converter-test how="wc-set" what="path" elt-id="2048"><![CDATA[*.txt]]></converter-test></converter><converter type-in="application/word" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="doc" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">doc</content>']]></converter-execute></converter><converter type-in="application/excel" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="xls" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">xls</content>']]></converter-execute></converter><converter type-in="application/powerpoint" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="ppt" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">ppt</content>']]></converter-execute></converter><converter type-in="application/ps" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="ps" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">ps</content>']]></converter-execute></converter><converter type-in="application/pdf" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="pdf" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">pdf</content>']]></converter-execute></converter><converter type-in="application/rtf" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="rtf" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">rtf</content>']]></converter-execute></converter><converter type-in="application/vnd.lotus-1-2-3" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="lotus123" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">lotus123</content>']]></converter-execute></converter><converter type-in="application/vnd.ms-project" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="msproject" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">msproject</content>']]></converter-execute></converter><converter type-in="application/outlook-msg" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="email" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">email</content>']]></converter-execute></converter><converter type-in="text/mail" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="email" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">email</content>']]></converter-execute></converter><converter type-in="application/vnd.sun.xml.writer" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="sxw" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">sxw</content>']]></converter-execute></converter><converter type-in="application/vnd.sun.xml.calc" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="sxc" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">sxc</content>']]></converter-execute></converter><converter type-in="application/vnd.sun.xml.impress" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="sxi" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">sxi</content>']]></converter-execute></converter><converter type-in="application/vnd.sun.xml.draw" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="sxd" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">sxd</content>']]></converter-execute></converter><converter type-in="application/vnd.sun.xml.math" type-out="application/vxml" fork="fork" attribute-name="filetype" attribute-value="sxm" timing-name="Filetype generator"><converter-execute><![CDATA[echo '<content name="filetype" action="none">sxm</content>']]></converter-execute></converter><converter type-in="message/rfc822" type-out="text/mail" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.writer" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.calc" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.impress" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.draw" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.math" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/octet-stream" type-out="unknown" timing-name="Type normalization" /><converter type-in="application/postscript" type-out="application/ps" timing-name="Type normalization" /><converter type-in="application/msword" type-out="application/word" timing-name="Type normalization" /><converter type-in="application/vnd.ms-powerpoint" type-out="application/powerpoint" timing-name="Type normalization" /><converter type-in="application/vnd.ms-excel" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/vnd.ms-word" type-out="application/word" timing-name="Type normalization" /><converter type-in="application/wordperfect5.1" type-out="application/wordperfect" timing-name="Type normalization" /><converter type-in="application/wordperfect6.1" type-out="application/wordperfect" timing-name="Type normalization" /><converter type-in="application/wordperfectd" type-out="application/wordperfect" timing-name="Type normalization" /><converter type-in="application/x-tar" type-out="application/tar" timing-name="Type normalization" /><converter type-in="application/x-zip" type-out="application/zip" timing-name="Type normalization" /><converter type-in="application/x-zip-compressed" type-out="application/zip" timing-name="Type normalization" /><converter type-in="application/x-shockwave-flash" type-out="application/flash" timing-name="Type normalization" /><converter type-in="application/shockwave-flash" type-out="application/flash" timing-name="Type normalization" /><converter type-in="unknown" type-out="application/temp" timing-name="Type normalization"><converter-test what="path" how="wc-set"><![CDATA[
*~
*.tmp
  ]]></converter-test></converter><converter type-in="application/word" type-out="application/rtf" timing-name="Type normalization"><converter-test how="wc-set" what="body"><![CDATA[{\rtf*]]></converter-test></converter><converter type-in="application/vxml-db" type-out="application/vxml-unnormalized" timing-name="Database seeds support"><parser type="xsl"><![CDATA[
  <xsl:variable name="title"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="action"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="abstract"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="urlparam"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="key"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="key-normalize"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="url-table"><![CDATA[true()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="content-type"><![CDATA['text']]]><![CDATA[]></xsl:variable>

  <xsl:variable name="urlproto"><![CDATA[false()]]]><![CDATA[]></xsl:variable>
 
<xsl:template match="/">
  <vce>
  <xsl:variable name="errors" select="//error" />
  <xsl:if test="$errors">
    <xsl:message>
      <xsl:value-of select="viv:concat($errors//text(), ' ')" />
    </xsl:message>
  </xsl:if>
  <xsl:for-each select="//more-results[viv:test(@start, '^[0-9]*$', 'regex')]">
    <xsl:choose>
      <xsl:when test="contains($crawl-url-url, '%java -classpath')">
        <xsl:variable name="url" select="concat(viv:replace($crawl-url-url, '--start [0-9]*$', ''), ' --start ', @start)" />
        <xsl:value-of select="viv:crawl-enqueue-url($url)" />
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="url" select="concat(viv:replace($crawl-url-url, '-s [0-9]*$', ''), ' -s ', @start)" />
        <xsl:value-of select="viv:crawl-enqueue-url($url)" />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>
  <xsl:apply-templates select="//document" />
  </vce>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:apply-templates select="*|text()|comment()|@*"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="text()|comment()|@*">
  <xsl:copy-of select="."/>
</xsl:template>

<xsl:template match="content|text()" mode="title">
  <xsl:param name="key"/>
  <xsl:param name="key-normalized"/>
  <xsl:param name="pos"/>

  <xsl:value-of select="viv:set(concat('title', @name), .)"/> 
  <content>
    <xsl:apply-templates select="@*" />
    <xsl:if test="string-length($key-normalized) > 0 and $key">
      <xsl:attribute name="vse-add-to-normalized">
        <xsl:value-of select="'vse-add-to-normalized'"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$key">
      <xsl:attribute name="add-to"><xsl:value-of select="$key"/></xsl:attribute>
    </xsl:if>
    <xsl:attribute name="name">title</xsl:attribute>
    <xsl:attribute name="type">
      <xsl:choose>
        <xsl:when test="dyn:evaluate($content-type)">
          <xsl:value-of select="dyn:evaluate($content-type)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>text</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>

    <xsl:if test="dyn:evaluate($action)">
      <xsl:attribute name="action"><xsl:value-of select="dyn:evaluate($action)"/></xsl:attribute>
    </xsl:if>

    <xsl:if test="dyn:evaluate($weight)">
      <xsl:variable name="weight-val">
        <xsl:value-of select="dyn:evaluate($weight)"/>
      </xsl:variable>

      <xsl:if test="viv:test($weight-val, '^[0-9.]+$', 'regex')">
        <xsl:attribute name="weight"><xsl:value-of select="dyn:evaluate($weight)"/></xsl:attribute>
      </xsl:if>
    </xsl:if>

    <xsl:if test="dyn:evaluate($output-action)">
      <xsl:attribute name="output-action"><xsl:value-of select="dyn:evaluate($output-action)"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="dyn:evaluate($value-mapping)"><xsl:value-of select="dyn:evaluate($value-mapping)"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
</xsl:template>

<xsl:template match="content|text()" mode="abstract">
  <xsl:param name="key"/>
  <xsl:param name="key-normalized"/>
  <xsl:param name="pos"/>

  <xsl:value-of select="viv:set(concat('abstract', @name), .)"/>

  <content>
    <xsl:apply-templates select="@*[not(name)]" />
    <xsl:if test="string-length($key-normalized) > 0 and $key">
      <xsl:attribute name="vse-add-to-normalized">
        <xsl:value-of select="'vse-add-to-normalized'"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$key">
      <xsl:attribute name="add-to"><xsl:value-of select="$key"/></xsl:attribute>
    </xsl:if>
    <xsl:attribute name="name">abstract</xsl:attribute>
    <xsl:if test="dyn:evaluate($action)">
      <xsl:attribute name="action"><xsl:value-of select="dyn:evaluate($action)"/></xsl:attribute>
    </xsl:if>

    <xsl:attribute name="type">
      <xsl:choose>
        <xsl:when test="dyn:evaluate($content-type)">
          <xsl:value-of select="dyn:evaluate($content-type)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>text</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>
    <xsl:if test="dyn:evaluate($weight)">
      <xsl:variable name="weight-val">
        <xsl:value-of select="dyn:evaluate($weight)"/>
      </xsl:variable>

      <xsl:if test="viv:test($weight-val, '^[0-9.]+$', 'regex')">
        <xsl:attribute name="weight"><xsl:value-of select="dyn:evaluate($weight)"/></xsl:attribute>
      </xsl:if>
    </xsl:if>
    <xsl:if test="dyn:evaluate($output-action)">
      <xsl:attribute name="output-action"><xsl:value-of select="dyn:evaluate($output-action)"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="dyn:evaluate($value-mapping)"><xsl:value-of select="dyn:evaluate($value-mapping)"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
</xsl:template>

<xsl:template match="content">
  <xsl:param name="key"/>
  <xsl:param name="key-normalized"/>
  <xsl:param name="pos"/>

  <xsl:if test="not(. = viv:get(concat('title', @name))) and not(. = viv:get(concat('abstract', @name)))">
  <content>
    <xsl:apply-templates select="@*"/>
    <xsl:if test="string-length($key-normalized) > 0 and $key">
      <xsl:attribute name="vse-add-to-normalized">
        <xsl:value-of select="'vse-add-to-normalized'"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$key">
      <xsl:attribute name="add-to"><xsl:value-of select="$key"/></xsl:attribute>
    </xsl:if>

    <xsl:attribute name="type">
      <xsl:choose>
        <xsl:when test="dyn:evaluate($content-type)">
          <xsl:value-of select="dyn:evaluate($content-type)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>text</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>
    <xsl:if test="dyn:evaluate($mapping)">
      <xsl:attribute name="name"><xsl:value-of select="dyn:evaluate($mapping)"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="dyn:evaluate($action)">
      <xsl:attribute name="action"><xsl:value-of select="dyn:evaluate($action)"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="dyn:evaluate($weight)">
      <xsl:variable name="weight-val">
        <xsl:value-of select="dyn:evaluate($weight)"/>
      </xsl:variable>

      <xsl:if test="viv:test($weight-val, '^[0-9.]+$', 'regex')">
        <xsl:attribute name="weight"><xsl:value-of select="dyn:evaluate($weight)"/></xsl:attribute>
      </xsl:if>
    </xsl:if>
    <xsl:if test="dyn:evaluate($output-action)">
      <xsl:attribute name="output-action"><xsl:value-of select="dyn:evaluate($output-action)"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="dyn:evaluate($value-mapping)"><xsl:value-of select="dyn:evaluate($value-mapping)"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
  </xsl:if>
</xsl:template>

<xsl:template match="document">
  <xsl:variable name="keyval" select="dyn:evaluate($key)"/>
  <xsl:variable name="url" select="dyn:evaluate($urlparam)"/>
  <xsl:variable name="urltable" select="dyn:evaluate($url-table)"/>

  <xsl:choose>
    <xsl:when test="dyn:evaluate($url-table)">
      <document>
        <xsl:copy-of select="@*"/>
        <xsl:if test="string-length($key-normalize) > 0">
          <xsl:attribute name="vse-key-normalized">
            <xsl:value-of select="'vse-key-normalized'"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:if test="dyn:evaluate($key)">
          <xsl:attribute name="vse-key"><xsl:value-of select="$keyval"/></xsl:attribute>
        </xsl:if>
        <xsl:if test="dyn:evaluate($urlparam)">
          <xsl:attribute name="url">
            <xsl:value-of select="viv:if-else(dyn:evaluate($urlproto), dyn:evaluate($urlproto), $url)"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:apply-templates select="dyn:evaluate($title)" mode="title">
          <xsl:with-param name="pos" select="position()"/>
        </xsl:apply-templates>
        <xsl:apply-templates select="dyn:evaluate($abstract)" mode="abstract">
          <xsl:with-param name="pos" select="position()"/>
        </xsl:apply-templates>
        <xsl:apply-templates select="*">
          <xsl:with-param name="pos" select="position()"/>
        </xsl:apply-templates>
      </document>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="dyn:evaluate($title)" mode="title">
        <xsl:with-param name="key" select="$keyval"/>
        <xsl:with-param name="key-normalized" select="$key-normalize"/>
        <xsl:with-param name="pos" select="position()"/>
      </xsl:apply-templates>
      <xsl:apply-templates select="dyn:evaluate($abstract)" mode="abstract">
        <xsl:with-param name="key" select="$keyval"/>
        <xsl:with-param name="key-normalized" select="$key-normalize"/>
        <xsl:with-param name="pos" select="position()"/>
      </xsl:apply-templates>
      <xsl:apply-templates select="*">
        <xsl:with-param name="key" select="$keyval"/>
        <xsl:with-param name="key-normalized" select="$key-normalize"/>
        <xsl:with-param name="pos" select="position()"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
]]></parser></converter><converter type-in="application/powerpoint" type-out="application/powerpoint-xml" timing-name="PPT to XML"><converter-execute><![CDATA[%bin/pptxml %source_file
]]></converter-execute></converter><converter type-in="application/powerpoint-xml" type-out="text/html" timing-name="PPT XML to HTML"><parser type="xsl"><![CDATA[<!-- -->

<xsl:template match="/">
  <xsl:variable name="presentation" select="/*/presentation"/>
  <xsl:variable name="meta" select="/top/summary/property" />

  <html>
    <head>
      <xsl:if test="$meta[@name='title']">
        <title><xsl:value-of select="$meta[@name='title']/@value" /></title>
      </xsl:if>
      <xsl:apply-templates select="$meta" mode="meta" />
    </head>
    <body>
      <xsl:choose>
        <xsl:when test="not($presentation/@version)">
          <xsl:call-template name="version-1"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="version-2"/>
        </xsl:otherwise>
      </xsl:choose>
    </body>
  </html>
</xsl:template>

<xsl:template mode="meta" match="*">
  <xsl:if test="@name">
    <meta name="{@name}" value="{@value}" />
  </xsl:if>
</xsl:template>

<xsl:template mode="text" match="TextCharsAtom|TextBytesAtom|CString">
  <xsl:variable name="header" select="(preceding-sibling::TextHeaderAtom[1])|(parent::TextHeaderAtom)" />
  <xsl:variable name="size">
    <xsl:choose>
      <xsl:when test="$header/@header = 0"><![CDATA[18]]]><![CDATA[]></xsl:when>
      <xsl:when test="$header/@header = 5"><![CDATA[24]]]><![CDATA[]></xsl:when>
      <xsl:when test="$header/@header = 6"><![CDATA[20]]]><![CDATA[]></xsl:when>
      <xsl:otherwise><![CDATA[0]]]><![CDATA[]></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:apply-templates select="str:tokenize(., '&#10;')" mode="nl">
    <xsl:with-param name="size" select="$size" />
  </xsl:apply-templates>
  <xsl:if test="$header/@header = '0'"><p /></xsl:if>
</xsl:template>

<xsl:template match="*" mode="nl">
  <xsl:param name="size" />

  <span>
    <xsl:if test="$size > 0">
      <xsl:attribute name="style">
        <xsl:text><![CDATA[font-size: ]]]><![CDATA[]></xsl:text>
        <xsl:value-of select="$size" />
        <xsl:text><![CDATA[pt;]]]><![CDATA[]></xsl:text>
      </xsl:attribute>
    </xsl:if>
    <xsl:value-of select="." />
  </span>
  <br />
</xsl:template>


<!-- VERSION 2 -->

<xsl:variable name="slides" select="//Slide"/>
<xsl:variable name="persist-refs" select="//persist-ref"/>

<xsl:template name="version-2">
  <xsl:variable name="lists" select="//Document/SlideListWithText[@instance=0]"/>
  <xsl:apply-templates mode="v2-body" select="$lists[position() = last()]"/>
</xsl:template>

<xsl:template mode="v2-body" match="SlidePersistAtom">
  <xsl:variable name="persist" select="."/>
  <xsl:variable name="id" select="@psrReference"/>
  <xsl:variable name="pr" select="$persist-refs[@id = $id]"/>
  <xsl:variable name="slide" select="$slides[@start = $pr/@offset]"/>

  <xsl:for-each select="$slide//msofbtClientTextbox">
    <xsl:apply-templates select="." mode="text"/>
    <xsl:for-each select=".//OutlineTextRefAtom">
      <xsl:variable name="instance" select="@ref"/>
      <xsl:apply-templates select="$persist//TextHeaderAtom[@instance = $instance]/*" mode="text"/>
    </xsl:for-each>
  </xsl:for-each>
  <hr/>
</xsl:template>
    

<!-- VERSION 1 -->

<xsl:template name="version-1">
  <xsl:variable name="slides" select="//Document//SlideListWithText[TextHeaderAtom]" />
  <xsl:variable name="slide" select="$slides[position() = last()]" />
  <xsl:apply-templates mode="v1-body" select="$slide" />
</xsl:template>

<xsl:template mode="v1-body" match="TextCharsAtom|TextBytesAtom|CString">
  <xsl:apply-templates mode="text" select="."/>
</xsl:template>

<xsl:template mode="v1-body" match="*">
  <xsl:apply-templates mode="v1-body" select="*" />
</xsl:template>

<xsl:template mode="v1-body" match="SlidePersistAtom">
  <hr />
</xsl:template>
]]></parser></converter><converter type-in="application/vnd.lotus-1-2-3" type-out="application/vnd.lotus-1-2-3-text" timing-name="Lotus 1-2-3"><converter-execute><![CDATA[vstrings --window 4 --min-char-pct 1 --min-space-pct 0 %source_file]]></converter-execute></converter><converter type-in="application/vnd.lotus-1-2-3-text" type-out="text/plain" timing-name="Lotus 1-2-3"><parser type="regex-text"><match token="^[8DP\\]?['\^&quot;]" goto="keep" /><state name="keep"><match token="$[8DP\\]?['\^&quot;]" goto="keep"><add-string><![CDATA[; ]]></add-string></match><match token="$" goto="discard" /><add-string /></state><state name="discard"><match token="^[8DP\\]?['\^&quot;]" goto="keep"><add-string><![CDATA[; ]]></add-string></match></state></parser></converter><converter type-in="outlook/mail" type-out="text/mailbox" elt-id="2054" timing-name="PST (Outlook) to mailbox"><converter-execute><![CDATA[%bin/readpst -w -r -o %target_dir %source_file > /dev/null]]></converter-execute></converter><converter type-in="text/mailbox" type-out="text/mail" elt-id="2056" timing-name="Mailbox to messages"><converter-execute><![CDATA[%bin/split-mail %target_dir]]></converter-execute></converter><converter type-in="text/mail" type-out="vivisimo/crawl-data" elt-id="2058" timing-name="Email message"><converter-execute><![CDATA[%bin/mail2vxml --parser vse-cache-parser-email --anchor %anchor 'snippet' 'subject=title' '*date' '*from' '*to']]></converter-execute></converter><converter type-in="application/documentum" type-out="application/vxml-unnormalized" elt-id="2061" timing-name="Documentum documents"><parser type="xsl"><![CDATA[
  <xsl:variable name="action"><![CDATA[viv:choose($name = 'title' or $name = 'description','cluster', 'none')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[viv:choose($name = 'title',3,1)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[viv:choose(@name = 'title', 'title', @name = 'subject', 'description', @name = 'r_modified_date', 'last-modified', @name = 'r_modifier', 'author')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[viv:choose($name = 'last-modified', concat(date:month-name(.), ' ',date:day-in-month(.),', ',date:year(.)))]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <vce>
    <xsl:apply-templates/>
  </vce>
</xsl:template>

<xsl:template match="vce">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:apply-templates select="*"/>
  </xsl:copy>
</xsl:template>


<xsl:template match="document">
  <xsl:variable name="urlroot" select="content[@name='url_root']"/>
  <xsl:variable name="objectid" select="content[@name='r_object_id']"/>
  <xsl:copy>
    <xsl:copy-of select="@*[name(.)!='id']"/>
    <xsl:if test="$urlroot and $objectid">
      <xsl:attribute name="url">
        <xsl:value-of select="concat($urlroot,$objectid)"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:apply-templates select="content"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:variable name="name" select="dyn:evaluate($mapping)"/>
  <xsl:variable name="a" select="dyn:evaluate($action)"/>
  <xsl:variable name="w" select="dyn:evaluate($weight)"/>
  <xsl:variable name="oa" select="dyn:evaluate($output-action)"/>
  <xsl:variable name="vm" select="dyn:evaluate($value-mapping)"/> 
  <xsl:if test="$name">
  <content>
    <xsl:copy-of select="@*"/>
    <xsl:attribute name="name"><xsl:value-of select="$name"/></xsl:attribute>
    <xsl:if test="$a">
      <xsl:attribute name="action"><xsl:value-of select="$a"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$w">
      <xsl:attribute name="weight"><xsl:value-of select="$w"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$oa">
      <xsl:attribute name="output-action"><xsl:value-of select="$oa"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$vm"><xsl:value-of select="$vm"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
  </xsl:if>
</xsl:template>



]]></parser></converter><converter type-out="application/vxml-unnormalized" type-in="application/lotus" elt-id="2063" timing-name="Lotus documents"><parser type="xsl"><![CDATA[
  <xsl:variable name="action"><![CDATA[viv:choose($name = 'title','cluster', 'none')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[viv:choose($name = 'title',3,1)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[viv:choose($name = 'snippet', 'summarize', '')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[viv:choose(@name = 'Subject', 'title', @name = 'Body', 'snippet')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[viv:choose($name = 'last-modified', concat(date:month-name(.), ' ',date:day-in-month(.),', ',date:year(.)))]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <vce>
    <xsl:apply-templates/>
  </vce>
</xsl:template>

<xsl:template match="vce">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:apply-templates select="*"/>
  </xsl:copy>
</xsl:template>


<xsl:template match="document">
  <xsl:variable name="urlroot" select="content[@name='url_root']"/>
  <xsl:variable name="objectid" select="content[@name='r_object_id']"/>
  <xsl:copy>
    <xsl:copy-of select="@*[name(.)!='id']"/>
    <xsl:if test="$urlroot and $objectid">
      <xsl:attribute name="url">
        <xsl:value-of select="concat($urlroot,$objectid)"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:apply-templates select="content"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:variable name="name" select="dyn:evaluate($mapping)"/>
  <xsl:variable name="a" select="dyn:evaluate($action)"/>
  <xsl:variable name="w" select="dyn:evaluate($weight)"/>
  <xsl:variable name="oa" select="dyn:evaluate($output-action)"/>
  <xsl:variable name="vm" select="dyn:evaluate($value-mapping)"/> 

  <content>
    <xsl:copy-of select="@*"/>
    <xsl:if test="$name">
      <xsl:attribute name="name"><xsl:value-of select="$name"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$a">
      <xsl:attribute name="action"><xsl:value-of select="$a"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$w">
      <xsl:attribute name="weight"><xsl:value-of select="$w"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$oa">
      <xsl:attribute name="output-action"><xsl:value-of select="$oa"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$vm"><xsl:value-of select="$vm"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
</xsl:template>



]]></parser></converter><converter type-in="application/sharepoint" type-out="application/vxml-unnormalized" elt-id="2065" timing-name="Sharepoint Documents"><parser type="xsl"><![CDATA[
  <xsl:variable name="action"><![CDATA[viv:choose($name = 'title' or $name = 'description','cluster', 'none')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[viv:choose($name = 'title',3,1)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[viv:choose($name  = 'description' or $name = 'title' or $name = 'author', 'bold')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[viv:choose(@name = 'Title' or @name = 'Description' or @name = 'Author', viv:str-to-lower(@name), @name = 'ows_Title' or @name = 'ows_Author', viv:str-to-lower(substring-after(@name, 'ows_')), @name = 'ows_Body', 'snippet', @name = 'LastModified' or @name = 'ows_Modified', 'last-modified')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[dyn:evaluate(viv:choose($name='author', "viv:replace(.,'^[[:digit:]]+;#','')"))]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <xsl:choose>
    <xsl:when test="viv:vivisimo-version-is-newer-than('5.0-5')">
      <vce>
        <xsl:apply-templates select="//document"/>
      </vce>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="v" select="viv:vivisimo-alloc()"/>
      <xsl:variable name="cn" select="viv:current-node(true())"/>
      <xsl:variable name="up" select="$cn/curl-options/curl-option[@name='user-password']"/>
      <xsl:variable name="xml">
        <declare name="no-recurse" initial-value="{viv:current-node()/@no-recurse}"/>
        <declare name="default-acl" initial-value="{viv:current-node()/@default-acl}"/>
        <call-function name="sharepoint-crawl">
          <with name="site-url"><xsl:value-of select="viv:replace($cn/@url,'\/*default.aspx$','')"/></with>
          <xsl:if test="$up">
            <with name="username"><xsl:value-of select="substring-before($up,':')"/></with>
            <with name="password"><xsl:value-of select="substring-after($up,':')"/></with>
          </xsl:if>
        </call-function>  
        <fetch timeout="300000" finish="finish"/>
      </xsl:variable>
      <xsl:value-of select="viv:vivisimo-input-xml($v, $xml)"/>
      <vce>
        <xsl:variable name="oxml" select="viv:vivisimo-xml($v)"/>
        <xsl:apply-templates select="$oxml//document"/>
        <xsl:for-each select="$oxml//crawl-url">
          <xsl:value-of select="viv:crawl-enqueue-url(false(),.)"/>
        </xsl:for-each>
      </vce>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="document">
  <xsl:copy>
    <xsl:copy-of select="@*[name(.)!='id']"/>
    <xsl:apply-templates select="content"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:variable name="name" select="dyn:evaluate($mapping)"/>
  <xsl:variable name="a" select="dyn:evaluate($action)"/>
  <xsl:variable name="w" select="dyn:evaluate($weight)"/>
  <xsl:variable name="oa" select="dyn:evaluate($output-action)"/>
  <xsl:variable name="vm" select="dyn:evaluate($value-mapping)"/> 
  <xsl:if test="$name">
  <content>
    <xsl:copy-of select="@*"/>
    <xsl:attribute name="name"><xsl:value-of select="$name"/></xsl:attribute>
    <xsl:if test="$a">
      <xsl:attribute name="action"><xsl:value-of select="$a"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$w">
      <xsl:attribute name="weight"><xsl:value-of select="$w"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$oa">
      <xsl:attribute name="output-action"><xsl:value-of select="$oa"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$vm"><xsl:value-of select="$vm"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
  </xsl:if>
</xsl:template>

]]></parser></converter><converter type-in="application/word" type-out="text/html" elt-id="2067" timing-name="Microsoft Word to HTML"><converter-execute><![CDATA[%bin/wvWare -1 -x %bin/wvHtml.xml %source_file
]]></converter-execute></converter><converter type-in="application/excel" type-out="text/html" elt-id="2069" timing-name="Microsoft Excel"><converter-execute><![CDATA[%bin/xlhtml -te %source_file]]></converter-execute></converter><converter type-in="application/wordperfect" type-out="text/html" elt-id="2071" timing-name="WordPerfect to HTML"><converter-execute><![CDATA[%bin/wpd2html %source_file > %target_file]]></converter-execute></converter><converter type-in="application/openoffice" type-out="text/html" elt-id="2073" timing-name="Open Office to HTML"><converter-execute><![CDATA[unzip -pq %source_file content.xml meta.xml | o3tohtml]]></converter-execute></converter><converter type-in="application/vnd.ms-project" type-out="application/vxml-unnormalized" elt-id="2075" timing-name="Microsoft Project"><converter-execute><![CDATA[mpp2vxml --content-name snippet  %source_file]]></converter-execute></converter><converter type-in="application/ps" type-out="text/plain" elt-id="2077" timing-name="Postscript (ps) to text"><converter-execute><![CDATA[%bin/ghostscript/gs -q -dNODISPLAY -dSAFER -dDELAYBIND -dWRITESYSTEMDICT -dSIMPLE -I%bin/ghostscript -c save -f %bin/ghostscript/ps2ascii.ps %source_file -c quit > %target_file]]></converter-execute></converter><converter type-in="application/pdf" type-out="text/html" elt-id="2079" timing-name="PDF to HTML"><converter-execute><![CDATA[%bin/pdftohtml -enc UTF-8 -i -noframes -c -stdout  %source_file | %bin/check-and-fix-utf8  | %bin/fix-pdf]]></converter-execute></converter><converter type-in="application/rtf" type-out="text/html" elt-id="2081" timing-name="RTF to HTML"><converter-execute><![CDATA[%bin/rtf2html %source_file]]></converter-execute></converter><converter type-in="application/outlook-msg" type-out="vivisimo/crawl-data" elt-id="2083" timing-name="Email: Outlook (MSG) "><converter-execute><![CDATA[%bin/msg2vxml --cache-parser vse-cache-parser-email %source_file]]></converter-execute></converter><converter type-in="application/flash" type-out="text/html" elt-id="2085" timing-name="Flash to HTML"><converter-execute><![CDATA[swf2html - < %source_file > %target_file]]></converter-execute></converter><converter type-in="application/tar" type-out="unknown" elt-id="2087" timing-name="TAR archive extractor"><converter-execute><![CDATA[
tar xf %source_file --no-same-owner --force-local --no-same-permissions --directory=%target_dir  > /dev/null && chmod -R +rwx %target_dir]]></converter-execute></converter><converter type-in="application/x-gzip" type-out="unknown" elt-id="2089" timing-name="Uncompress gzip (.gz)"><converter-execute><![CDATA[gunzip -f < %source_file > %target_file]]></converter-execute></converter><converter type-in="application/zip" type-out="unknown" elt-id="2091" timing-name="Uncompress ZIP files"><converter-execute><![CDATA[unzip -o %source_file -d %target_dir && chmod -R +rwx %target_dir]]></converter-execute></converter><converter type-in="application/x-compress" type-out="unknown" elt-id="2093" timing-name="Uncompress compress (.Z) files"><converter-execute><![CDATA[%bin/compress -d -c %source_file > %target_file && chmod +rwx %target_file]]></converter-execute></converter><converter type-in="text/html" type-out="application/vxml-unnormalized" elt-id="2095" timing-name="HTML to XML"><parser type="html-xsl"><![CDATA[
  <xsl:variable name="meta-names"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="meta-action"><![CDATA[cluster-bold]]]><![CDATA[]></xsl:variable>


<!--

Convert HTML to Vivisimo XML.

This XSL stylesheet does two things.  First it selects a title for the
page.  If the page is a PDF, Word, Powerpoint or Excel document, we will
consider replacing the title in the document.  The title selection is
based on looking for large fonts near the start of the document.  You
can explore this transformation and customize it as you see fit.

The second thing that this XSLT does is to take a subset of the HTML and
put it into a content named snippet.  Near the end of this parser, there
are a series of template matches that decide which tags will be placed
into the content, which will be discard and which will be discarded along
with their sub-nodes.

-->

<xsl:output method="xml" encoding="utf-8" />
<xsl:strip-space elements="*" />

<xsl:variable name="include-alts">
</xsl:variable>

<!-- useful short-cuts -->

<xsl:variable name="generator" select="/html/head/meta[@name = 'GENERATOR']" />
<xsl:variable name="is-pdf" select="viv:test($url, '\.pdf$|\.pdf#', 'cregex')" />
<xsl:variable name="is-doc" select="starts-with($generator/@content, 'wvWare/wvWare')" />
<xsl:variable name="is-ppt" select="viv:test($url, '\.pp[st]$|\.pp[st]#', 'cregex')" />
<xsl:variable name="is-excel" select="$generator/@content = 'xlhtml'" />
<xsl:variable name="bad-title" select="$is-pdf or $is-doc or $is-ppt" />

<!-- main match -->

<xsl:template match="/">
  <document>
    <xsl:call-template name="select-title" />
    <xsl:call-template name="process-meta" />
    <xsl:variable name="body" select="/*"/>
    <xsl:variable name="keep-mode" select="not($is-pdf or $is-doc or $is-ppt or $is-excel) and /*/*[@before-keep or @after-keep][1]"/>

    <xsl:if test="$keep-mode">
      <content name="pre-snippet" weight="0.1" output-action="summarize">
        <xsl:apply-templates select="viv:if-else($body, $body, /*)" 
         mode="x"
        >
          <xsl:with-param name="keep" select="1"/>
        </xsl:apply-templates>
      </content>
    </xsl:if>

    <content name="snippet" weight="1" output-action="summarize">
      <xsl:apply-templates select="viv:if-else($body, $body, *|text())" mode="x" >
        <xsl:with-param name="keep" select="viv:if-else($keep-mode, 2, 0)"/>
      </xsl:apply-templates>
    </content>

    <xsl:if test="$keep-mode">
      <content name="post-snippet" weight="0.1" output-action="summarize">
        <xsl:apply-templates select="viv:if-else($body, $body, *|text())" 
         mode="x"
        >
          <xsl:with-param name="keep" select="3"/>
        </xsl:apply-templates>
      </content>
    </xsl:if>

  </document>
</xsl:template>

<xsl:template match="text()" />

<!-- Meta tag handling -->

<xsl:template name="process-meta">
  <xsl:if test="$meta-names">
    <xsl:apply-templates select="/*/head//meta" mode="metas"/>
  </xsl:if>
</xsl:template>

<xsl:template match="meta" mode="metas">
  <xsl:variable name="n" select="viv:str-to-lowercase(normalize-space(@name))"/>
  <xsl:variable name="t" select="normalize-space(@content)" />

  <xsl:if test=
   "$t and $t != '' and $n and viv:test($n, $meta-names, 'wc-set')"
  >
    <content name="{$n}" action="{$meta-action}"
      weight="{1}"
    >
      <xsl:value-of select="$t" />
    </content>
  </xsl:if>
</xsl:template>

<!-- Title extraction -->

<xsl:template name="select-title">
  <xsl:variable name="t0" select="//title[normalize-space(.) != '']" />
  <xsl:variable name="t" select="viv:replace(viv:replace($t0, '^Microsoft Word - ', ''), '\.doc$', '')"/>

  <xsl:choose>
    <xsl:when test="$is-excel">
      <xsl:variable name="title"
        select="normalize-space(viv:concat(//h1[1]//text(), ' '))"
      />
      <xsl:if test="not(viv:test($title, '^Sheet[1-9][0-9]*$', 'regex'))">
        <content name="title" output-action="bold" weight="3">
          <xsl:value-of select="$title"/>
        </content>
      </xsl:if>
    </xsl:when>
    <xsl:when test="$bad-title">
      <xsl:call-template name="conditional-title-extractor">
        <xsl:with-param name="title" select="$t"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$t">
      <content name="title" output-action="bold" weight="3">
        <xsl:value-of select="$t"/>
      </content>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template name="conditional-title-extractor">
  <xsl:param name="title" select="//title" />

  <xsl:variable name="spans" select="//span" />
  <xsl:variable name="t-title" select="str:tokenize($title)" />

  <xsl:choose>
    <xsl:when test="string-length(normalize-space($title)) > 3">
      <xsl:call-template name="find-title-words">
        <xsl:with-param name="spans" select="$spans[position() &lt;= 100]" />
        <xsl:with-param name="title" select="$title" />
        <xsl:with-param name="t-title" select="$t-title" />
        <xsl:with-param name="pos" select="1" />
        <xsl:with-param name="may-miss" select="floor(count($t-title) div 4)" />
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$spans">
      <xsl:call-template name="generate-title">
        <xsl:with-param name="spans" select="$spans[position() &lt;= 100]" />
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template name="find-title-words">
  <xsl:param name="spans" />
  <xsl:param name="title" />
  <xsl:param name="t-title" />
  <xsl:param name="pos" />
  <xsl:param name="may-miss" />

  <xsl:choose>
    <xsl:when test="$pos > 0 and $pos > count($t-title)">
      <!-- found all title words, keep this title -->
      <content name="title" output-action="bold" weight="3">
        <xsl:value-of select="$title" />
      </content>
    </xsl:when>
    <xsl:when test="$pos &lt;= count($t-title) and $spans[viv:test(., concat('*', viv:replace($t-title[position() = $pos], '[[:punct:]]', '', 'g'), '*'), 'wc')]">
      <!-- found this title word, look for the next one -->
      <xsl:call-template name="find-title-words">
        <xsl:with-param name="spans" select="$spans" />
        <xsl:with-param name="title" select="$title" />
        <xsl:with-param name="t-title" select="$t-title" />
        <xsl:with-param name="pos" select="$pos + 1" />
        <xsl:with-param name="may-miss" select="$may-miss" />
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$may-miss > 0">
      <xsl:call-template name="find-title-words">
        <xsl:with-param name="spans" select="$spans" />
        <xsl:with-param name="title" select="$title" />
        <xsl:with-param name="t-title" select="$t-title" />
        <xsl:with-param name="pos" select="$pos + 1" />
        <xsl:with-param name="may-miss" select="$may-miss - 1" />
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <!-- no match for this word, generate a title -->
      <xsl:call-template name="generate-title">
        <xsl:with-param name="spans" select="$spans" />
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="generate-title">
  <xsl:param name="spans" />

  <content name="title" output-action="bold" weight="3">
    <xsl:choose>
      <xsl:when test="$is-pdf">
        <xsl:call-template name="pdf-title-extractor">
          <xsl:with-param name="spans" select="$spans" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$is-doc">
        <xsl:call-template name="doc-title-extractor">
          <xsl:with-param name="spans" select="$spans" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$is-ppt">
        <xsl:call-template name="doc-title-extractor">
          <xsl:with-param name="spans" select="$spans[position() &lt;= 10]" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </content>
</xsl:template>

<!-- DOC/PPT title extractor -->

<xsl:template name="doc-title-extractor">
  <xsl:param name="spans" />

  <xsl:variable name="sizes-str">
    <xsl:apply-templates select="$spans" mode="doc-emit-sizes">
      <xsl:sort select="number(substring-before(substring-after(@style, 'font-size: '), 'pt'))" data-type="number" order="descending" />
    </xsl:apply-templates>
  </xsl:variable>

  <xsl:variable name="sizes" select="str:tokenize($sizes-str)" />

  <xsl:call-template name="doc-title-size">
    <xsl:with-param name="spans" select="$spans" />
    <xsl:with-param name="sizes" select="$sizes" />
    <xsl:with-param name="pos" select="1" />
  </xsl:call-template>
</xsl:template>

<xsl:template name="doc-title-size">
  <xsl:param name="spans" />
  <xsl:param name="sizes" />
  <xsl:param name="pos" />

  <xsl:variable name="pt" select="$sizes[position() = $pos]" />
  <xsl:if test="$pos &lt;= count($sizes)">
    <xsl:choose>
      <xsl:when test="$pos = 1 or $pt != $sizes[position() = $pos - 1]">

        <xsl:variable name="positions-str">
          <xsl:apply-templates select="$spans" mode="doc-positions">
            <xsl:with-param name="pt" select="$pt" />
          </xsl:apply-templates>
        </xsl:variable>
        <xsl:variable name="positions" select="str:tokenize($positions-str)" />
        <xsl:variable name="position0" select="$positions[1]" />
        <xsl:variable name="s" select="$spans[substring-before(substring-after(@style, 'font-size: '), 'pt') = $pt and position() &lt;= $position0 + 10]" />

        <xsl:choose>
          <xsl:when test="$s//text()[string-length(normalize-space(.)) >= 5]">
            <xsl:call-template name="output-title-strings">
              <xsl:with-param name="text" select="$s" />
              <xsl:with-param name="pos" select="1" />
            </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="doc-title-size">
              <xsl:with-param name="spans" select="$spans" />
              <xsl:with-param name="sizes" select="$sizes" />
              <xsl:with-param name="pos" select="$pos + 1" />
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="doc-title-size">
          <xsl:with-param name="spans" select="$spans" />
          <xsl:with-param name="sizes" select="$sizes" />
          <xsl:with-param name="pos" select="$pos + 1" />
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template>

<xsl:template match="*" mode="doc-positions">
  <xsl:param name="pt" />
  <xsl:if test="substring-before(substring-after(@style, 'font-size: '), 'pt') = $pt">
    <xsl:value-of select="position()" />
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template>

<xsl:template mode="doc-emit-sizes" match="*">
  <xsl:value-of select="substring-before(substring-after(@style, 'font-size: '), 'pt')" /><xsl:text> </xsl:text>
</xsl:template>

<!-- PDF title extractor -->

<xsl:template name="pdf-title-extractor">
  <xsl:param name="spans" />

  <!-- make sure we don't try to extract a title from a blank page,
       look for pages that have at least one div on them.
    -->
  <xsl:variable name="pages" select="/*/*/div[div]" />
  <xsl:if test="$pages">
    <xsl:variable name="css" select="str:tokenize(viv:replace(viv:replace($pages[1]/style/comment(),'\{[^}]*font-size: *', ',', 'g'),'px[^}]*} *', '', 'g'), '&#10;')" />

    <xsl:variable name="biggest-str">
      <xsl:apply-templates select="$css" mode="strip-tags">
        <xsl:sort select="number(substring-after(text(), ','))" data-type="number" order="descending" />
      </xsl:apply-templates>
    </xsl:variable>

    <xsl:variable name="biggest" select="str:tokenize($biggest-str, ' ')" />
    <xsl:call-template name="pdf-title-size">
      <xsl:with-param name="sizes" select="$biggest" />
      <xsl:with-param name="pos" select="1" />
      <xsl:with-param name="spans" select="$spans" />
    </xsl:call-template>
  </xsl:if>
</xsl:template>

<xsl:template name="pdf-title-size">
  <xsl:param name="sizes" />
  <xsl:param name="pos" />
  <xsl:param name="spans" />

  <xsl:variable name="this" select="$sizes[position() = $pos]" />
  <xsl:variable name="size" select="substring-after($this, ',')" />
  <xsl:variable name="classes" select="$sizes[substring-after(., ',') = $size]" />

  <xsl:variable name="class-condition">
    false()
    <xsl:for-each select="$classes">
      or @class = '<xsl:value-of select="substring-after(substring-before(., ','), '.')" />'
    </xsl:for-each>
  </xsl:variable>

  <xsl:variable name="positions-str">
    <xsl:apply-templates select="$spans" mode="pdf-positions">
      <xsl:with-param name="class-condition" select="$class-condition" />
    </xsl:apply-templates>
  </xsl:variable>
  <xsl:variable name="positions" select="str:tokenize($positions-str)" />
  <xsl:variable name="position0" select="$positions[1]" />
  <xsl:variable name="s" select="dyn:evaluate(concat('$spans[position() &lt;= $position0 + 10 and (', $class-condition, ')]'))" />

  <xsl:choose>
    <xsl:when test="count($classes) = 0">
      <!-- will go into an infinite loop doing nothing -->
    </xsl:when>
    <xsl:when test="not(str:split(viv:concat($s//text()))[string-length(text())
> 1])">
      <xsl:call-template name="pdf-title-size">
        <xsl:with-param name="sizes" select="$sizes" />
        <xsl:with-param name="pos" select="$pos + count($classes)" />
        <xsl:with-param name="spans" select="$spans" />
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$s//text()[string-length(normalize-space(.)) >= 5]">
      <xsl:call-template name="output-title-strings">
        <xsl:with-param name="text" select="$s" />
        <xsl:with-param name="pos" select="1" />
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$classes">
      <xsl:call-template name="pdf-title-size">
        <xsl:with-param name="sizes" select="$sizes" />
        <xsl:with-param name="pos" select="$pos + count($classes)" />
        <xsl:with-param name="spans" select="$spans" />
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template match="*" mode="pdf-positions">
  <xsl:param name="class-condition" />
  <xsl:if test="dyn:evaluate($class-condition)">
    <xsl:value-of select="position()" />
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template>

<xsl:template name="output-title-strings">
  <xsl:param name="text" />
  <xsl:param name="pos" />
  <xsl:param name="limit" select="viv:if-else($is-ppt, 1, 100)" />
  <xsl:param name="bytes-output" select="0" />
  <xsl:param name="last-s" select="''" />

  <xsl:variable name="s">
    <xsl:for-each select="$text[position() = $pos]//text()">
      <xsl:value-of select="normalize-space(.)" />
      <xsl:text> </xsl:text>
    </xsl:for-each>
  </xsl:variable>

  <xsl:if test="string-length($s) &lt;= $limit or  5*$bytes-output &lt; $limit">

    <xsl:variable name="display-s">
      <xsl:if test="$s != $last-s">
        <xsl:value-of select="$s" />
      </xsl:if>
    </xsl:variable>

    <xsl:value-of select="$display-s" />

    <xsl:if test="$pos &lt; count($text)">
      <xsl:call-template name="output-title-strings">
        <xsl:with-param name="text" select="$text" />
        <xsl:with-param name="pos" select="$pos + 1" />
        <xsl:with-param name="limit" select="$limit - string-length($display-s)" />
        <xsl:with-param name="bytes-output" select="$bytes-output + string-length($display-s)" />
        <xsl:with-param name="last-s" select="$s" />
      </xsl:call-template>
    </xsl:if>
  </xsl:if>
</xsl:template>

<xsl:template match="text()" mode="strip-tags">
  <xsl:value-of select="." /><xsl:text> </xsl:text>
</xsl:template>

<xsl:template mode="x" match="*">
  <xsl:param name="keep"/>
  <xsl:if test="@alt">
    <xsl:apply-templates select="." mode="check-alt">
      <xsl:with-param name="keep" select="$keep"/>
    </xsl:apply-templates>
  </xsl:if>
  <xsl:text> </xsl:text>
  <xsl:apply-templates mode="x">
    <xsl:with-param name="keep" select="$keep"/>
  </xsl:apply-templates>
  <xsl:text> </xsl:text>
</xsl:template>

<xsl:template mode="x" match="font|span|div|td|a|h1|h2|h3|h4|h5|b|p|br|hr|li|option">
  <xsl:param name="keep"/>
  <xsl:if test="$keep = 0 or ($keep = 1 and @before-keep) or ($keep = 2 and @keep) or ($keep = 3 and @after-keep)">
    <xsl:if test="@alt">
      <xsl:apply-templates select="." mode="check-alt"/>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="(name() = 'br' and not($is-pdf)) or name() = 'hr' or name() = 'p'">
        <xsl:apply-templates mode="show-tag" select=".">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:when test="true() or text()[string-length(.) > 10 or normalize-space(.) != '']">
        <xsl:apply-templates mode="show-tag" select=".">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="x">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template>

<xsl:template mode="x" match="title|head|meta|script|style">
  <xsl:text> </xsl:text>
</xsl:template>


<xsl:template mode="show-tag" match="*">
  <xsl:param name="keep"/>

  <xsl:variable name="keeping" select="
      $keep = 0 or 
      (
        ( $keep = 1 and @before-keep ) or
        ( $keep = 3 and @after-keep   ) or
        ( $keep = 2 and not(@before-keep or @after-keep) )
      )
  "/>

    <xsl:if test="@alt and $keeping">
      <xsl:apply-templates select="." mode="check-alt"/>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="name() = 'span' and $is-doc">
        <!-- spans are purely font information for word documents, don't keep
             them. -->
        <xsl:apply-templates mode="x">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:when test="node()">
        <xsl:if test="$keeping">
          <xsl:value-of select="concat('&lt;', name(), '>')"/>
        </xsl:if>
        <xsl:apply-templates mode="x">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
        <xsl:if test="$keeping">
          <xsl:value-of select="concat('&lt;/', name(), '>')"/>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="$keeping">
          <xsl:value-of select="concat('&lt;', name(), '/>')"/>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>

</xsl:template>

<xsl:template mode="x" match="@*"/>

<!-- Otherwise, print the text.  Remove extra white space to make it
     easier to read.
  -->

<xsl:template mode="x" match="text()">
  <xsl:param name="keep"/>

  <xsl:if test="
      $keep = 0 or 
      (
        ( $keep = 1 and ../@before-keep ) or
        ( $keep = 3 and ../@after-keep   ) or
        ( $keep = 2 and not(../@before-keep or ../@after-keep) )
      )
  ">
    <xsl:value-of select="." />
  </xsl:if>
</xsl:template>

<xsl:template mode="check-alt" match="a|img">
  <xsl:if test="$include-alts and @alt and normalize-space(@alt) != ''">
    <xsl:text> </xsl:text>
    <xsl:value-of select="@alt"/>
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template>


]]></parser></converter><converter type-in="text/plain" type-out="application/vxml-unnormalized" elt-id="2097" timing-name="Text to XML"><parser name="text2vxml"><match token="..*" goto="#end"><add-document /><add-content type="text" name="snippet" /></match></parser></converter><converter type-in="unknown" type-out="application/dbf" elt-id="2099"><converter-test how="wc-set" what="path" elt-id="2100"><![CDATA[*.dbf]]></converter-test></converter><converter type-in="application/dbf" type-out="text/csv" elt-id="2101" timing-name="DBF to CSV"><converter-execute><![CDATA[dbf --csv - %source_file | %bin/../iso2utf]]></converter-execute></converter><converter type-in="text/csv" type-out="application/vxml-unnormalized" elt-id="2103" timing-name="CSV to XML"><converter-execute><![CDATA[%bin/csv2vxml %source_file]]></converter-execute></converter><converter type-in="text/xml" type-out="application/vxml-unnormalized" elt-id="2105" timing-name="XML to Vivisimo XML"><parser type="xsl"><![CDATA[<xsl:template match="/">
  <document>
    <content name="snippet" output-action="summarize">
      <xsl:apply-templates select="*" mode="xml-to-plain-text" />
    </content>
  </document>
</xsl:template>

<xsl:template match="*" mode="xml-to-plain-text">
  <xsl:text><![CDATA[<]]]><![CDATA[]></xsl:text>
  <xsl:value-of select="name()" />
  <xsl:text> </xsl:text>
  <xsl:choose>
    <xsl:when test="text()|*|comment()">
      <xsl:text><![CDATA[>]]]><![CDATA[]></xsl:text>
      <xsl:apply-templates select="text()|*|comment()" mode="xml-to-plain-text" />
      <xsl:text><![CDATA[</]]]><![CDATA[]></xsl:text>
      <xsl:value-of select="name()" />
      <xsl:text><![CDATA[>]]]><![CDATA[]></xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text><![CDATA[/>]]]><![CDATA[]></xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>]]></parser></converter><converter type-in="application/vxml-unnormalized" type-out="application/vxml-unnormalized" elt-id="2107" timing-name="Normalization"><parser type="xsl"><![CDATA[
  <xsl:variable name="max-title-length"><![CDATA[120]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="date-bias-what"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="date-bias-xpath"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="last-modified"><![CDATA[true]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="last-modified-weight"><![CDATA[-1]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="crawled-date"><![CDATA[true]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="crawled-date-weight"><![CDATA[-1]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-detection"><![CDATA[true]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-contents"><![CDATA[title|snippet]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-content"><![CDATA[language]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-bytes"><![CDATA[50000]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="static-summary-names"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="static-summary-bytes"><![CDATA[]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <vce>
    <xsl:apply-templates/>
  </vce>
</xsl:template>

<xsl:template match="vce">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates/>
  </xsl:copy>
</xsl:template>

<xsl:template match="document">
  <xsl:copy>
    <xsl:apply-templates select="@*[not(name() = $date-bias-what)]" />
    <xsl:apply-templates mode="document-attributes" select="."/>
    <xsl:call-template name="handle-date-bias" />
    <xsl:call-template name="output-dates" />
    <xsl:if test="$language-detection and $language-detection = 'true' and function-available('viv:classify-language')">
      <xsl:apply-templates mode="language" select="."/>
    </xsl:if>
    <xsl:apply-templates select="*"/>
    <xsl:apply-templates mode="document" select="." />
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:choose>
    <xsl:when test="$static-summary-names and viv:test(@name, $static-summary-names, 'wc-set')">
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:attribute name="action">index-only</xsl:attribute>
        <xsl:apply-templates mode="content-attributes" select="."/>
        <xsl:copy-of select="text()"/>
      </xsl:copy>
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:attribute name="weight">-1</xsl:attribute>
        <xsl:apply-templates mode="content-attributes" select="."/>
        <xsl:call-template name="chop">
          <xsl:with-param name="text" select="viv:if-else(@type = 'text', ., viv:replace(., '&lt;[^>]*>', ' ', 'g'))"/>
          <xsl:with-param name="max-length" select="viv:evaluate($static-summary-bytes)"/>
        </xsl:call-template>
      </xsl:copy>
    </xsl:when>
<!--<xsl:when test="$normalize-spaces and $normalize-spaces = 'true'">
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:copy-of select="normalize-space(.)"/>
      </xsl:copy>
    </xsl:when>
-->
    <xsl:otherwise>
      <xsl:apply-templates mode="content-attributes" select="."/>
      <xsl:copy-of select="."/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:apply-templates mode="content" select="."/>
</xsl:template>

<xsl:template match="text()|comment()|@*">
  <xsl:copy />
</xsl:template>

<!-- *******************************************
               Language detection
     ******************************************* -->

<xsl:template mode="language" match="document">
  <xsl:variable name="c" select="content[viv:test(@name, $language-contents, 'wc-set')]"/>
  <xsl:variable name="html">
    <xsl:call-template name="language-text">
      <xsl:with-param name="c" select="$c[not(@type) or @type != 'text']"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="text">
    <xsl:call-template name="language-text">
      <xsl:with-param name="c" select="$c[@type = 'text']"/>
      <xsl:with-param name="len" select="string-length($html)"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="l" select="viv:classify-language($html, 'html', $text, 'text')"/>
  <content name="{$language-content}" weight="0" action="none">
    <xsl:value-of select="viv:if-else($l and $l != '', $l, 'unknown')"/>
  </content>
</xsl:template>

<xsl:template name="language-text">
  <xsl:param name="c" />
  <xsl:param name="i" select="1" />
  <xsl:param name="len" select="0" />

  <xsl:choose>
    <xsl:when test="$i > count($c)"/>
    <xsl:when test="$language-bytes &lt; 0">
      <xsl:value-of select="$c[$i]"/>
      <xsl:call-template name="language-text">
        <xsl:with-param name="c" select="$c"/>
        <xsl:with-param name="i" select="$i + 1"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$len >= $language-bytes"/>
    <xsl:otherwise>
      <xsl:variable name="l" select="string-length($c[$i])"/>
      <xsl:value-of select="substring($c[$i], 1, $language-bytes - $len)"/>
      <xsl:call-template name="language-text">
        <xsl:with-param name="c" select="$c"/>
        <xsl:with-param name="i" select="$i + 1"/>
        <xsl:with-param name="len" select="$len + $l"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<!-- *******************************************
               Date bias
     ******************************************* -->

<xsl:template name="handle-date-bias">
  <xsl:variable name="at">
    <xsl:choose>
      <xsl:when test="$date-bias-xpath and number(dyn:evaluate($date-bias-xpath)) > 0">
        <xsl:value-of select="dyn:evaluate($date-bias-xpath)"/>
      </xsl:when>
      <xsl:when test="$crawl-url-last-modified and number($crawl-url-last-modified) > 0">
        <xsl:value-of select="$crawl-url-last-modified" />
      </xsl:when>
      <xsl:when test="$crawl-url-at and number($crawl-url-at) > 0">
        <xsl:value-of select="$crawl-url-at" />
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:if test="$date-bias-what != '' and $at and number($at) > 0">
    <xsl:attribute name="{$date-bias-what}">
      <xsl:value-of select="viv:if-else($date-bias-what != 'la-score', 1, 0) + (1 div ((date:seconds() - $at) div (60*60*24) + 1.5) * viv:if-else(@*[name() = $date-bias-what], @*[name() = $date-bias-what], 1))" />
    </xsl:attribute>
  </xsl:if>
</xsl:template>

<!-- *******************************************
               Output dates
     ******************************************* -->

<xsl:template name="output-dates">
  <xsl:if test="$crawl-url-last-modified and number($crawl-url-last-modified) > 0 and $last-modified and $last-modified = 'true' and not(content[@name='last-modified'])">
    <content name="last-modified" action="none" weight="{$last-modified-weight}">
      <xsl:call-template name="print-date">
        <xsl:with-param name="secs" select="$crawl-url-last-modified" />
      </xsl:call-template>
    </content>
  </xsl:if>
  <xsl:if test="$crawled-date and $crawled-date = 'true' and $crawl-url-at and $crawl-url-at != '' and number($crawl-url-at) > 0">
    <content name="crawled-date" action="none" weight="{$crawled-date-weight}">
      <xsl:call-template name="print-date">
        <xsl:with-param name="secs" select="$crawl-url-at" />
      </xsl:call-template>
    </content>
  </xsl:if>
</xsl:template>

<xsl:template name="print-date">
  <xsl:param name="secs" />
  <xsl:attribute name="seconds">
    <xsl:value-of select="$secs"/>
  </xsl:attribute>
  <xsl:param name="duration" select="concat('P0Y0M0DT0H0M', $secs, 'S')" />
  <xsl:variable name="d" select="date:add('1970-01-01T00:00:00Z', $duration)" />

  <xsl:value-of select="substring(date:month-name($d), 1, 3)" />
  <xsl:text> </xsl:text>
  <xsl:value-of select="date:day-in-month($d)" />,
  <xsl:value-of select="date:year($d)" />
  <xsl:text> </xsl:text>
  <xsl:value-of select="format-number(date:hour-in-day($d), '00')" />
  <xsl:text>:</xsl:text>
  <xsl:value-of select="format-number(date:minute-in-hour($d), '00')" />
  <xsl:text>:</xsl:text>
  <xsl:value-of select="format-number(date:second-in-minute($d), '00')" />
  <xsl:text> GMT</xsl:text>
</xsl:template>

<!-- *******************************************
               Truncate long titles
     ******************************************* -->

<xsl:template match="content[@name='title' and $max-title-length > 0]">
  <xsl:copy>
    <xsl:apply-templates select="@*|comment()|*" />
    <xsl:call-template name="chop">
      <xsl:with-param name="text" select="." />
      <xsl:with-param name="max-length" select="$max-title-length" />
    </xsl:call-template>
  </xsl:copy>
  <xsl:apply-templates mode="content" select="."/>
</xsl:template>


<!-- Truncate strings -->

<xsl:template name="chop">
  <xsl:param name="text" />
  <xsl:param name="max-length" />

  <xsl:variable name="t" select="normalize-space($text)" />

  <xsl:choose>
    <xsl:when test="string-length($t) > $max-length">
      <xsl:variable name="t-hacked" select="substring($t, 1, $max-length)" />
      <xsl:value-of select="viv:replace($t-hacked, '[^[:space:],\.;:>]*$', '')" />
      <xsl:text>...</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$t" />
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<!-- Placeholders for the hooks -->

<xsl:template mode="document" match="*"/>
<xsl:template mode="document-attributes" match="*"/>
<xsl:template mode="content" match="*"/>
<xsl:template mode="content-attributes" match="*"/>

]]></parser></converter><converter type-in="application/vxml-unnormalized" type-out="application/vxml" elt-id="2109" /></converters></vse-config><vse-meta name="sharepoint-portal-full" creator="test" create-time="1176838246" push-toggle="push-toggle" elt-id="1" max-elt-id="1" /></vse-collection>
