<?xml version="1.0" encoding="UTF-8" standalone="yes" ?><interaction id="se.overview" cur-time="1374079713"><data id="" /><data id="" /><data id="" /><data id="" /><data id="" /><full><vse-collection modified="1374079597" modified-by="gary_testing@QA" name="content-size-4" filebase="/var/www/html/vivisimo//data/search-collections/5a1/content-size-4"><vse-config elt-id="2025" max-elt-id="2125"><crawler elt-id="2026"><crawl-urls><crawl-url url="smb://netapp1a.bigdatalab.ibm.com/testbed5-data/test_data/compression/calgary" /><crawl-url url="smb://netapp1a.bigdatalab.ibm.com/testbed5-data/test_data/compression/cantrbry" /><crawl-url url="smb://netapp1a.bigdatalab.ibm.com/testbed5-data/test_data/compression/large" /><crawl-url url="smb://netapp1a.bigdatalab.ibm.com/testbed5-data/test_data/compression/misc" /><crawl-url url="smb://netapp1a.bigdatalab.ibm.com/testbed5-data/test_data/compression/artificl" /></crawl-urls><crawl-condition-when field="protocol"><crawl-pattern><![CDATA[smb]]></crawl-pattern><crawl-condition-when field="host" how="wc-set"><crawl-pattern><![CDATA[netapp1a.bigdatalab.ibm.com]]></crawl-pattern><crawl-condition-when field="user" how="wc-set"><crawl-pattern><![CDATA[*]]></crawl-pattern><crawl-condition-when field="path"><crawl-pattern><![CDATA[/testbed5-data/test_data/compression/*]]></crawl-pattern><curl-options><curl-option name="default-allow"><![CDATA[allow]]></curl-option><curl-option name="user-password"><![CDATA[\qasamba:[[vcrypt]]rIYJO7Az0Zc9QvtqWkxuhw==]]></curl-option><crawl-extender-option name="archive"><![CDATA[false]]></crawl-extender-option><crawl-extender-option name="max-policies-per-handle"><![CDATA[255]]></crawl-extender-option></curl-options></crawl-condition-when></crawl-condition-when></crawl-condition-when></crawl-condition-when><crawl-condition-when field="protocol"><crawl-pattern><![CDATA[smb]]></crawl-pattern><crawl-condition-when field="host" how="wc-set"><crawl-pattern><![CDATA[netapp1a.bigdatalab.ibm.com]]></crawl-pattern><crawl-condition-when field="user" how="wc-set"><crawl-pattern><![CDATA[*]]></crawl-pattern><crawl-condition-when field="path"><crawl-pattern><![CDATA[/testbed5-data/test_data/compression/*]]></crawl-pattern><curl-options><curl-option name="default-allow"><![CDATA[allow]]></curl-option><curl-option name="user-password"><![CDATA[\qasamba:[[vcrypt]]rIYJO7Az0Zc9QvtqWkxuhw==]]></curl-option><crawl-extender-option name="archive"><![CDATA[false]]></crawl-extender-option><crawl-extender-option name="max-policies-per-handle"><![CDATA[255]]></crawl-extender-option></curl-options></crawl-condition-when></crawl-condition-when></crawl-condition-when></crawl-condition-when><crawl-condition-when field="protocol"><crawl-pattern><![CDATA[smb]]></crawl-pattern><crawl-condition-when field="host" how="wc-set"><crawl-pattern><![CDATA[netapp1a.bigdatalab.ibm.com]]></crawl-pattern><crawl-condition-when field="user" how="wc-set"><crawl-pattern><![CDATA[*]]></crawl-pattern><crawl-condition-when field="path"><crawl-pattern><![CDATA[/testbed5-data/test_data/compression/*]]></crawl-pattern><curl-options><curl-option name="default-allow"><![CDATA[allow]]></curl-option><curl-option name="user-password"><![CDATA[\qasamba:[[vcrypt]]rIYJO7Az0Zc9QvtqWkxuhw==]]></curl-option><crawl-extender-option name="archive"><![CDATA[false]]></crawl-extender-option><crawl-extender-option name="max-policies-per-handle"><![CDATA[255]]></crawl-extender-option></curl-options></crawl-condition-when></crawl-condition-when></crawl-condition-when></crawl-condition-when><crawl-condition-when field="protocol"><crawl-pattern><![CDATA[smb]]></crawl-pattern><crawl-condition-when field="host" how="wc-set"><crawl-pattern><![CDATA[netapp1a.bigdatalab.ibm.com]]></crawl-pattern><crawl-condition-when field="user" how="wc-set"><crawl-pattern><![CDATA[*]]></crawl-pattern><crawl-condition-when field="path"><crawl-pattern><![CDATA[/testbed5-data/test_data/compression/*]]></crawl-pattern><curl-options><curl-option name="default-allow"><![CDATA[allow]]></curl-option><curl-option name="user-password"><![CDATA[\qasamba:[[vcrypt]]rIYJO7Az0Zc9QvtqWkxuhw==]]></curl-option><crawl-extender-option name="archive"><![CDATA[false]]></crawl-extender-option><crawl-extender-option name="max-policies-per-handle"><![CDATA[255]]></crawl-extender-option></curl-options></crawl-condition-when></crawl-condition-when></crawl-condition-when></crawl-condition-when><crawl-condition-when field="protocol"><crawl-pattern><![CDATA[smb]]></crawl-pattern><crawl-condition-when field="host" how="wc-set"><crawl-pattern><![CDATA[netapp1a.bigdatalab.ibm.com]]></crawl-pattern><crawl-condition-when field="user" how="wc-set"><crawl-pattern><![CDATA[*]]></crawl-pattern><crawl-condition-when field="path"><crawl-pattern><![CDATA[/testbed5-data/test_data/compression/*]]></crawl-pattern><curl-options><curl-option name="default-allow"><![CDATA[allow]]></curl-option><curl-option name="user-password"><![CDATA[\qasamba:[[vcrypt]]rIYJO7Az0Zc9QvtqWkxuhw==]]></curl-option><crawl-extender-option name="archive"><![CDATA[false]]></crawl-extender-option><crawl-extender-option name="max-policies-per-handle"><![CDATA[255]]></crawl-extender-option></curl-options></crawl-condition-when></crawl-condition-when></crawl-condition-when></crawl-condition-when><crawl-extender protocol="smb" collection="content-size-4" exec="%java -Djpf.plugin.home='/var/www/html/vivisimo/lib/java/plugins' -classpath %classpath -Xmx160m -XX:+DisplayVMOutputToStderr -Djava.io.tmpdir='/var/www/html/vivisimo/tmp' -Dviv.collection.name='content-size-4' -Dviv.protocol='smb' com.vivisimo.connector.ConnectorRunner" dns="dns"><crawl-extender-option name="classname"><![CDATA[plugin:smb.plugin@connector]]></crawl-extender-option></crawl-extender><crawl-condition-when field="query" how="wc-set"><crawl-pattern><![CDATA[N=A
N=D
M=A
M=D
S=A
S=D
D=A
D=D]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[N M S D]]></curl-option></curl-options></crawl-condition-when><crawl-may-not-have field="path"><crawl-pattern><![CDATA[*.aif
*.arc
*.aiff
*.asf
*.au
*.avi
*.bin
*.bmp
*.cab
*.class
*.dbx
*.dll
*.exe
*.fpt
*.gif
*.img
*.iso
*.jar
*.kpg
*.lib
*.max
*.mdb
*.mp4
*.mpa
*.mpg
*.mpeg
*.mov
*.moov
*.msi
*.ns2
*.ns3
*.ns4
*.ocx
*.ogg
*.p65
*.pfc
*.png
*.psd
*.qt
*.qxd
*.ra
*.ram
*.rpm
*.rm
*.sea
*.so
*.smi
*.smil
*.swp
*.sys
*.tif
*.tiff
*.tmb
*.vsd
*.wav
*.wma
*.wmv
*.ymg
*.yps
~$*.doc
*/~$*.doc
*/Thumbs.db
]]></crawl-pattern></crawl-may-not-have><crawl-condition-when field="path"><crawl-pattern><![CDATA[*/bugzilla/*.cgi]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[bug_status email1 emailtype1 emailassigned_to1 emailreporter1 order]]></curl-option></curl-options><crawl-may-not-have field="path"><crawl-pattern><![CDATA[*/bugzilla/showdependencytree.cgi
*/bugzilla/long_list.cgi
*/bugzilla/show_activity.cgi
*/bugzilla/showdependencygraph.cgi]]></crawl-pattern></crawl-may-not-have></crawl-condition-when><crawl-may-not-have field="path"><crawl-pattern><![CDATA[/d[0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9](/[^/]*)?]]></crawl-pattern></crawl-may-not-have><crawl-may-not-have><crawl-pattern><![CDATA[*/webcalendar/view.asp*
*/webcalendar/seclogin.asp*
*/webcalendar/reg.asp*]]></crawl-pattern></crawl-may-not-have><crawl-may-not-have><crawl-pattern><![CDATA[*/webevent.cgi?*cmd=*cal=*
*/webevent.cgi?*cal=*cmd=* ]]></crawl-pattern></crawl-may-not-have><crawl-condition-when field="protocol" how="wc-set"><crawl-pattern><![CDATA[file
exec
smb]]></crawl-pattern><crawl-condition-when field="host" how="wc"><crawl-pattern><![CDATA[?*]]></crawl-pattern><curl-options><curl-option name="delay"><![CDATA[0]]></curl-option></curl-options></crawl-condition-when><crawl-condition-except field="host" how="wc"><crawl-pattern><![CDATA[?*]]></crawl-pattern><curl-options><curl-option name="delay"><![CDATA[0]]></curl-option></curl-options></crawl-condition-except></crawl-condition-when><crawl-condition-when field="url" how="cregex"><crawl-pattern><![CDATA[\.nsf(/[^/]*)?\?Open(View|Database)(&.*)?$]]></crawl-pattern><curl-options><curl-option name="case-normalize"><![CDATA[url]]></curl-option><curl-option name="remove-cgi-parameters"><![CDATA[Collapse Expand Count ExpandView Start]]></curl-option></curl-options><crawl-replace this="&amp;*$" that="&amp;start=1&amp;Count=10000&amp;ExpandView" /></crawl-condition-when><crawl-condition-when field="path" how="cregex"><crawl-pattern><![CDATA[\.nsf(/[^/]*)*/[a-f0-9]{32}?$]]></crawl-pattern><crawl-condition-when field="path" how="wc-set"><crawl-pattern><![CDATA[*/$file/*]]></crawl-pattern><curl-options><curl-option name="case-normalize"><![CDATA[url]]></curl-option></curl-options><crawl-replace this="\.[nN][Ss][Ff]/[a-fA-F0-9]{32}" that=".nsf/0" /></crawl-condition-when><crawl-condition-when field="query" how="wc-set"><crawl-pattern><![CDATA[OpenDocument
OpenDocument&*
]]></crawl-pattern><curl-options><curl-option name="case-normalize"><![CDATA[url]]></curl-option></curl-options><crawl-replace this="\.[nN][Ss][Ff]/[a-fA-F0-9]{32}" that=".nsf/0" /></crawl-condition-when><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[Collapse Expand Count ExpandView Start ExpandSection]]></curl-option></curl-options></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[*&sid=*]]></crawl-pattern><crawl-replace this="&amp;sid=[^&amp;]*" that="&amp;sid=0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[sid=*]]></crawl-pattern><crawl-replace this="\?sid=[^&amp;]*" that="?sid=0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[*&PHPSESSID=*]]></crawl-pattern><crawl-replace this="&amp;PHPSESSID=[^&amp;]*" that="&amp;PHPSESSID=0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[PHPSESSID=*]]></crawl-pattern><crawl-replace this="\?PHPSESSID=[^&amp;]*" that="?PHPSESSID=0" /></crawl-condition-when><crawl-condition-when field="path"><crawl-pattern><![CDATA[*;jsessionid=*]]></crawl-pattern><crawl-replace this="%3[bB]jsessionid%3[dD][^?]*" that="%3Bjsessionid%3D0" /></crawl-condition-when><crawl-condition-when field="query"><crawl-pattern><![CDATA[*__VIEWSTATE=*]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[__VIEWSTATE]]></curl-option></curl-options></crawl-condition-when><crawl-may-not-have field="query"><crawl-pattern><![CDATA[*&MSCSProfile=*
MSCSProfile=*]]></crawl-pattern></crawl-may-not-have><crawl-condition-when field="port"><crawl-pattern><![CDATA[8765]]></crawl-pattern><curl-options /><crawl-may-not-have field="path"><crawl-pattern><![CDATA[query.html]]></crawl-pattern></crawl-may-not-have></crawl-condition-when><crawl-condition-when field="path"><crawl-pattern><![CDATA[*/wiki/*]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[action previous version]]></curl-option></curl-options></crawl-condition-when><crawl-condition-when field="path"><crawl-pattern><![CDATA[*/bugzilla/*.cgi]]></crawl-pattern><curl-options><curl-option name="remove-cgi-parameters"><![CDATA[bug_status email1 emailtype1 emailassigned_to1 emailreporter1 order]]></curl-option></curl-options><crawl-may-not-have field="path"><crawl-pattern><![CDATA[*/bugzilla/showdependencytree.cgi
*/bugzilla/long_list.cgi
*/bugzilla/show_activity.cgi
*/bugzilla/showdependencygraph.cgi]]></crawl-pattern></crawl-may-not-have></crawl-condition-when></crawler><vse-index elt-id="2036"><vse-index-option name="max-content-size" elt-id="2118"><![CDATA[12000000]]></vse-index-option><vse-index-option name="output-contents" elt-id="2037"><![CDATA[title]]></vse-index-option><vse-index-option name="fast-index" elt-id="2039"><![CDATA[last-modified|date]]></vse-index-option><vse-url-equivs name="vse-url-equivs" elt-id="2040"><vse-url-equiv old-prefix="smb://" new-prefix="file://///" elt-id="2119" /></vse-url-equivs></vse-index><converters elt-id="2042"><converter type-in="application/ms-office-container" program="unzip -l %source_file | ms-container-guess" timing-name="Guess MS Office 2007" /><converter type-in="application/word|application/excel|application/powerpoint" program="guess-office-2007 %source_file" timing-name="Check MS Office version" /><converter type-in="application/ms-ooxml-word" type-out="text/html"><converter-execute><![CDATA[unzip -pq %source_file word/*.xml docProps/*.xml | wpmltohtml > %target_file]]></converter-execute></converter><converter type-in="application/ms-ooxml-excel" type-out="text/html"><converter-execute><![CDATA[unzip -pq %source_file xl/workbook.xml docProps/core.xml xl/sharedStrings.xml xl/worksheets/sheet*.xml | %bin/ssmltohtml > %target_file]]></converter-execute></converter><converter type-in="application/ms-ooxml-powerpoint" type-out="text/html"><converter-execute><![CDATA[unzip -pq %source_file docProps/core.xml ppt/slides/slide*.xml ppt/notesSlides/notesSlide*.xml | %bin/pmltohtml > %target_file]]></converter-execute></converter><converter type-in="unknown" type-out="dead" elt-id="2043" timing-name="Binary file extensions (filter)"><converter-test what="url" how="wc-set"><![CDATA[*#*.aif
*#*.arc
*#*.aiff
*#*.asf
*#*.au
*#*.avi
*#*.bin
*#*.bmp
*#*.cab
*#*.class
*#*.dbx
*#*.dll
*#*.exe
*#*.fpt
*#*.gif
*#*.img
*#*.iso
*#*.jar
*#*.kpg
*#*.lib
*#*.max
*#*.mdb
*#*.mp4
*#*.mpa
*#*.mpg
*#*.mpeg
*#*.mov
*#*.moov
*#*.msi
*#*.ns2
*#*.ns3
*#*.ns4
*#*.ocx
*#*.ogg
*#*.p65
*#*.pfc
*#*.png
*#*.psd
*#*.qt
*#*.qxd
*#*.ra
*#*.ram
*#*.rpm
*#*.rm
*#*.sea
*#*.so
*#*.smi
*#*.smil
*#*.swp
*#*.sys
*#*.tif
*#*.tiff
*#*.tmb
*#*.vsd
*#*.wav
*#*.wma
*#*.wmv
*#*.ymg
*#*.yps
*#~$*.doc
*#*/~$*.doc
*#*/Thumbs.db
]]></converter-test></converter><converter type-in="unknown" program="guess-content %source_file" timing-name="Guess content" elt-id="2045" /><converter type-in="application/ms-office" program="ms-guess %source_file" timing-name="Guess MS Office" elt-id="2046" /><converter type-in="unknown" type-out="text/plain" elt-id="2047"><converter-test how="wc-set" what="path" elt-id="2048"><![CDATA[*.txt]]></converter-test></converter><converter type-in="application/word2" type-out="application/word2" attribute-name="filetypes" attribute-value="doc" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/word" type-out="application/word" attribute-name="filetypes" attribute-value="doc" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/ms-ooxml-word" type-out="application/ms-ooxml-word" attribute-name="filetypes" attribute-value="doc" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/excel" type-out="application/excel" attribute-name="filetypes" attribute-value="xls" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/ms-ooxml-excel" type-out="application/ms-ooxml-excel" attribute-name="filetypes" attribute-value="xls" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/powerpoint" type-out="application/powerpoint" attribute-name="filetypes" attribute-value="ppt" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/ms-ooxml-powerpoint" type-out="application/ms-ooxml-powerpoint" attribute-name="filetypes" attribute-value="ppt" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/ps" type-out="application/ps" attribute-name="filetypes" attribute-value="ps" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/pdf" type-out="application/pdf" attribute-name="filetypes" attribute-value="pdf" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/rtf" type-out="application/rtf" attribute-name="filetypes" attribute-value="rtf" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/vnd.lotus-1-2-3" type-out="application/vnd.lotus-1-2-3" attribute-name="filetypes" attribute-value="lotus123" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/vnd.ms-project" type-out="application/vnd.ms-project" attribute-name="filetypes" attribute-value="msproject" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/outlook-msg" type-out="application/outlook-msg" attribute-name="filetypes" attribute-value="email" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/wordperfect" type-out="application/wordperfect" attribute-name="filetypes" attribute-value="wordperfect" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/openoffice" type-out="application/openoffice" attribute-name="filetypes" attribute-value="openoffice" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/flash" type-out="application/flash" attribute-name="filetypes" attribute-value="flash" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="text/mail" type-out="text/mail" attribute-name="filetypes" attribute-value="email" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/vnd.sun.xml.writer" type-out="application/vnd.sun.xml.writer" attribute-name="filetypes" attribute-value="sxw" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/vnd.sun.xml.calc" type-out="application/vnd.sun.xml.calc" attribute-name="filetypes" attribute-value="sxc" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/vnd.sun.xml.impress" type-out="application/vnd.sun.xml.impress" attribute-name="filetypes" attribute-value="sxi" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/vnd.sun.xml.draw" type-out="application/vnd.sun.xml.draw" attribute-name="filetypes" attribute-value="sxd" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/vnd.sun.xml.math" type-out="application/vnd.sun.xml.math" attribute-name="filetypes" attribute-value="sxm" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/zip" type-out="application/zip" attribute-name="filetypes" attribute-value="zip" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/x-gzip" type-out="application/x-gzip" attribute-name="filetypes" attribute-value="zip" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="application/tar" type-out="application/tar" attribute-name="filetypes" attribute-value="zip" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="text/html" type-out="text/html" attribute-name="filetypes" attribute-value="html" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="text/plain" type-out="text/plain" attribute-name="filetypes" attribute-value="text" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="text/xml" type-out="text/xml" attribute-name="filetypes" attribute-value="xml" attribute-sep=" " timing-name="Filetype generator" /><converter type-in="message/rfc822" type-out="text/mail" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.text" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.text-template" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.text-web" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.text-master" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.graphics" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.graphics-template" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.presentation" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.presentation-template" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.spreadsheet" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.spreadsheet-template" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.chart" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.oasis.opendocument.formula" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.writer" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.calc" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.impress" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.draw" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/vnd.sun.xml.math" type-out="application/openoffice" timing-name="Type normalization" /><converter type-in="application/octet-stream" type-out="unknown" timing-name="Type normalization" /><converter type-in="application/postscript" type-out="application/ps" timing-name="Type normalization" /><converter type-in="application/msword" type-out="application/word" timing-name="Type normalization" /><converter type-in="application/vnd.ms-pps" type-out="application/powerpoint" timing-name="Type normalization" /><converter type-in="application/vnd.ms-powerpoint" type-out="application/powerpoint" timing-name="Type normalization" /><converter type-in="application/vnd.ms-powerpoint.*" type-out="application/powerpoint" timing-name="Type normalization" /><converter type-in="application/vnd.openxmlformats-officedocument.presentationml.*" type-out="application/ms-ooxml-powerpoint" timing-name="Type normalization" /><converter type-in="application/msexcel" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/mxexcel" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/vnd.ms-excel" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/vnd.ms-excel.*" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/vnd.openxmlformats-officedocument.spreadsheetml.*" type-out="application/ms-ooxml-excel" timing-name="Type normalization" /><converter type-in="application/vnd.ms-excelapplication/vnd.ms-excel" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/x-excel" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/x-msexcel" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/x-msexcelapplication/x-msexcel" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/x-ms-excel" type-out="application/excel" timing-name="Type normalization" /><converter type-in="vnd.ms-excel/application" type-out="application/excel" timing-name="Type normalization" /><converter type-in="application/vnd.ms-onenote" type-out="application/onenote" timing-name="Type normalization" /><converter type-in="application/vnd.ms-word" type-out="application/word" timing-name="Type normalization" /><converter type-in="application/vnd.ms-word.*" type-out="application/word" timing-name="Type normalization" /><converter type-in="application/vnd.openxmlformats-officedocument.wordprocessingml.*" type-out="application/ms-ooxml-word" timing-name="Type normalization" /><converter type-in="application/wordperfect5.1" type-out="application/wordperfect" timing-name="Type normalization" /><converter type-in="application/wordperfect6.1" type-out="application/wordperfect" timing-name="Type normalization" /><converter type-in="application/wordperfectd" type-out="application/wordperfect" timing-name="Type normalization" /><converter type-in="application/x-tar" type-out="application/tar" timing-name="Type normalization" /><converter type-in="application/x-zip" type-out="application/zip" timing-name="Type normalization" /><converter type-in="application/x-zip-compressed" type-out="application/zip" timing-name="Type normalization" /><converter type-in="application/x-shockwave-flash" type-out="application/flash" timing-name="Type normalization" /><converter type-in="application/shockwave-flash" type-out="application/flash" timing-name="Type normalization" /><converter type-in="unknown" type-out="application/temp" timing-name="Type normalization"><converter-test what="path" how="wc-set"><![CDATA[
*~
*.tmp
  ]]></converter-test></converter><converter type-in="application/msg" type-out="application/outlook-msg" timing-name="Type normalization" /><converter type-in="application/vxml-db" type-out="application/vxml-unnormalized" elt-id="2051" timing-name="Database seeds support"><parser type="xsl"><![CDATA[
  <xsl:variable name="title"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="action"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="abstract"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="urlparam"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="key"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="key-normalize"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="url-table"><![CDATA[true()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="content-type"><![CDATA['text']]]><![CDATA[]></xsl:variable>

  <xsl:variable name="urlproto"><![CDATA[false()]]]><![CDATA[]></xsl:variable>
 
<xsl:template match="/">
  <vce>
  <xsl:variable name="errors" select="//error" />
  <xsl:if test="$errors">
    <xsl:message>
      <xsl:value-of select="viv:concat($errors//text(), ' ')" />
    </xsl:message>
  </xsl:if>
  <xsl:for-each select="//more-results[viv:test(@start, '^[0-9]*$', 'regex')]">
    <xsl:choose>
      <xsl:when test="contains($crawl-url-url, '%java -classpath')">
        <xsl:variable name="url" select="concat(viv:replace($crawl-url-url, '--start [0-9]*$', ''), ' --start ', @start)" />
        <xsl:value-of select="viv:crawl-enqueue-url($url)" />
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="url" select="concat(viv:replace($crawl-url-url, '-s [0-9]*$', ''), ' -s ', @start)" />
        <xsl:value-of select="viv:crawl-enqueue-url($url)" />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>
  <xsl:apply-templates select="//document" />
  </vce>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:apply-templates select="*|text()|comment()|@*"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="text()|comment()|@*">
  <xsl:copy-of select="."/>
</xsl:template>

<xsl:template match="content|text()" mode="title">
  <xsl:param name="key"/>
  <xsl:param name="key-normalized"/>
  <xsl:param name="pos"/>

  <xsl:value-of select="viv:set(concat('title', @name), .)"/> 
  <content>
    <xsl:apply-templates select="@*" />
    <xsl:if test="string-length($key-normalized) > 0 and $key">
      <xsl:attribute name="vse-add-to-normalized">
        <xsl:value-of select="'vse-add-to-normalized'"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$key">
      <xsl:attribute name="add-to"><xsl:value-of select="$key"/></xsl:attribute>
    </xsl:if>
    <xsl:attribute name="name">title</xsl:attribute>
    <xsl:attribute name="type">
      <xsl:choose>
        <xsl:when test="dyn:evaluate($content-type)">
          <xsl:value-of select="dyn:evaluate($content-type)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>text</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>

    <xsl:if test="dyn:evaluate($action)">
      <xsl:attribute name="action"><xsl:value-of select="dyn:evaluate($action)"/></xsl:attribute>
    </xsl:if>

    <xsl:if test="dyn:evaluate($weight)">
      <xsl:variable name="weight-val">
        <xsl:value-of select="dyn:evaluate($weight)"/>
      </xsl:variable>

      <xsl:if test="viv:test($weight-val, '^[0-9.]+$', 'regex')">
        <xsl:attribute name="weight"><xsl:value-of select="dyn:evaluate($weight)"/></xsl:attribute>
      </xsl:if>
    </xsl:if>

    <xsl:if test="dyn:evaluate($output-action)">
      <xsl:attribute name="output-action"><xsl:value-of select="dyn:evaluate($output-action)"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="dyn:evaluate($value-mapping)"><xsl:value-of select="dyn:evaluate($value-mapping)"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
</xsl:template>

<xsl:template match="content|text()" mode="abstract">
  <xsl:param name="key"/>
  <xsl:param name="key-normalized"/>
  <xsl:param name="pos"/>

  <xsl:value-of select="viv:set(concat('abstract', @name), .)"/>

  <content>
    <xsl:apply-templates select="@*[not(name)]" />
    <xsl:if test="string-length($key-normalized) > 0 and $key">
      <xsl:attribute name="vse-add-to-normalized">
        <xsl:value-of select="'vse-add-to-normalized'"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$key">
      <xsl:attribute name="add-to"><xsl:value-of select="$key"/></xsl:attribute>
    </xsl:if>
    <xsl:attribute name="name">abstract</xsl:attribute>
    <xsl:if test="dyn:evaluate($action)">
      <xsl:attribute name="action"><xsl:value-of select="dyn:evaluate($action)"/></xsl:attribute>
    </xsl:if>

    <xsl:attribute name="type">
      <xsl:choose>
        <xsl:when test="dyn:evaluate($content-type)">
          <xsl:value-of select="dyn:evaluate($content-type)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>text</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>
    <xsl:if test="dyn:evaluate($weight)">
      <xsl:variable name="weight-val">
        <xsl:value-of select="dyn:evaluate($weight)"/>
      </xsl:variable>

      <xsl:if test="viv:test($weight-val, '^[0-9.]+$', 'regex')">
        <xsl:attribute name="weight"><xsl:value-of select="dyn:evaluate($weight)"/></xsl:attribute>
      </xsl:if>
    </xsl:if>
    <xsl:if test="dyn:evaluate($output-action)">
      <xsl:attribute name="output-action"><xsl:value-of select="dyn:evaluate($output-action)"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="dyn:evaluate($value-mapping)"><xsl:value-of select="dyn:evaluate($value-mapping)"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
</xsl:template>

<xsl:template match="content">
  <xsl:param name="key"/>
  <xsl:param name="key-normalized"/>
  <xsl:param name="pos"/>

  <xsl:if test="not(. = viv:get(concat('title', @name))) and not(. = viv:get(concat('abstract', @name)))">
  <content>
    <xsl:apply-templates select="@*"/>
    <xsl:if test="string-length($key-normalized) > 0 and $key">
      <xsl:attribute name="vse-add-to-normalized">
        <xsl:value-of select="'vse-add-to-normalized'"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$key">
      <xsl:attribute name="add-to"><xsl:value-of select="$key"/></xsl:attribute>
    </xsl:if>

    <xsl:attribute name="type">
      <xsl:choose>
        <xsl:when test="dyn:evaluate($content-type)">
          <xsl:value-of select="dyn:evaluate($content-type)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>text</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>
    <xsl:if test="dyn:evaluate($mapping)">
      <xsl:attribute name="name"><xsl:value-of select="dyn:evaluate($mapping)"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="dyn:evaluate($action)">
      <xsl:attribute name="action"><xsl:value-of select="dyn:evaluate($action)"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="dyn:evaluate($weight)">
      <xsl:variable name="weight-val">
        <xsl:value-of select="dyn:evaluate($weight)"/>
      </xsl:variable>

      <xsl:if test="viv:test($weight-val, '^[0-9.]+$', 'regex')">
        <xsl:attribute name="weight"><xsl:value-of select="dyn:evaluate($weight)"/></xsl:attribute>
      </xsl:if>
    </xsl:if>
    <xsl:if test="dyn:evaluate($output-action)">
      <xsl:attribute name="output-action"><xsl:value-of select="dyn:evaluate($output-action)"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="dyn:evaluate($value-mapping)"><xsl:value-of select="dyn:evaluate($value-mapping)"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
  </xsl:if>
</xsl:template>

<xsl:template match="document">
  <xsl:variable name="keyval" select="dyn:evaluate($key)"/>
  <xsl:variable name="url" select="dyn:evaluate($urlparam)"/>
  <xsl:variable name="urltable" select="dyn:evaluate($url-table)"/>

  <xsl:choose>
    <xsl:when test="dyn:evaluate($url-table)">
      <document>
        <xsl:copy-of select="@*"/>
        <xsl:if test="string-length($key-normalize) > 0">
          <xsl:attribute name="vse-key-normalized">
            <xsl:value-of select="'vse-key-normalized'"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:if test="dyn:evaluate($key)">
          <xsl:attribute name="vse-key"><xsl:value-of select="$keyval"/></xsl:attribute>
        </xsl:if>
        <xsl:if test="dyn:evaluate($urlparam)">
          <xsl:attribute name="url">
            <xsl:value-of select="viv:if-else(dyn:evaluate($urlproto), dyn:evaluate($urlproto), $url)"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:if test="dyn:evaluate($title)">
          <xsl:apply-templates select="dyn:evaluate($title)" mode="title">
            <xsl:with-param name="pos" select="position()"/>
          </xsl:apply-templates>
        </xsl:if>
        <xsl:if test="dyn:evaluate($abstract)">
          <xsl:apply-templates select="dyn:evaluate($abstract)" mode="abstract">
            <xsl:with-param name="pos" select="position()"/>
          </xsl:apply-templates> 
        </xsl:if>
        <xsl:apply-templates select="*">
          <xsl:with-param name="pos" select="position()"/>
        </xsl:apply-templates>
      </document>
    </xsl:when>
    <xsl:otherwise>
      <xsl:if test="dyn:evaluate($title)">
        <xsl:apply-templates select="dyn:evaluate($title)" mode="title">
          <xsl:with-param name="key" select="$keyval"/>
          <xsl:with-param name="key-normalized" select="$key-normalize"/>
          <xsl:with-param name="pos" select="position()"/>
        </xsl:apply-templates>
      </xsl:if>
      <xsl:if test="dyn:evaluate($abstract)">
        <xsl:apply-templates select="dyn:evaluate($abstract)" mode="abstract">
          <xsl:with-param name="key" select="$keyval"/>
          <xsl:with-param name="key-normalized" select="$key-normalize"/>
          <xsl:with-param name="pos" select="position()"/>
        </xsl:apply-templates>
      </xsl:if>
      <xsl:apply-templates select="*">
        <xsl:with-param name="key" select="$keyval"/>
        <xsl:with-param name="key-normalized" select="$key-normalize"/>
        <xsl:with-param name="pos" select="position()"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
]]></parser></converter><converter fallback="application/ms-office-container" type-in="application/powerpoint" type-out="application/powerpoint-xml" timing-name="PPT to XML"><converter-execute><![CDATA[%bin/pptxml %source_file]]></converter-execute></converter><converter type-in="application/powerpoint-xml" type-out="text/html" timing-name="PPT XML to HTML"><parser type="xsl"><![CDATA[<!-- -->

<xsl:template match="/">
  <xsl:variable name="presentation" select="/*/presentation"/>
  <xsl:variable name="meta" select="/top/summary/property" />

  <html>
    <head>
      <xsl:if test="$meta[@name='title']">
        <title><xsl:value-of select="$meta[@name='title']/@value" /></title>
      </xsl:if>
      <xsl:apply-templates select="$meta" mode="meta" />
    </head>
    <body>
      <xsl:choose>
        <xsl:when test="not($presentation/@version)">
          <xsl:call-template name="version-1"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="version-2"/>
        </xsl:otherwise>
      </xsl:choose>
    </body>
  </html>
</xsl:template>

<xsl:template mode="meta" match="*">
  <xsl:if test="@name">
    <meta name="{@name}" content="{@value}" />
  </xsl:if>
</xsl:template>

<xsl:template mode="text" match="TextCharsAtom|TextBytesAtom|CString">
  <xsl:variable name="header" select="(preceding-sibling::TextHeaderAtom[1])|(parent::TextHeaderAtom)" />
  <xsl:variable name="size">
    <xsl:choose>
      <xsl:when test="$header/@header = 0"><![CDATA[18]]]><![CDATA[]></xsl:when>
      <xsl:when test="$header/@header = 5"><![CDATA[20]]]><![CDATA[]></xsl:when>
      <xsl:when test="$header/@header = 6"><![CDATA[24]]]><![CDATA[]></xsl:when>
      <xsl:otherwise><![CDATA[0]]]><![CDATA[]></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:apply-templates select="str:tokenize(., '&#10;')" mode="nl">
    <xsl:with-param name="size" select="$size" />
  </xsl:apply-templates>
  <xsl:if test="$header/@header = '0'"><p /></xsl:if>
</xsl:template>

<xsl:template match="*" mode="nl">
  <xsl:param name="size" />

  <span>
    <xsl:if test="$size > 0">
      <xsl:attribute name="style">
        <xsl:text><![CDATA[font-size: ]]]><![CDATA[]></xsl:text>
        <xsl:value-of select="$size" />
        <xsl:text><![CDATA[pt;]]]><![CDATA[]></xsl:text>
      </xsl:attribute>
    </xsl:if>
    <xsl:value-of select="." />
  </span>
  <br />
</xsl:template>


<!-- VERSION 2 -->

<xsl:variable name="slides" select="//Slide"/>
<xsl:variable name="persist-refs" select="//persist-ref"/>

<xsl:template name="version-2">
  <xsl:variable name="lists" select="//Document/SlideListWithText[@instance=0]"/>
  <xsl:apply-templates mode="v2-body" select="$lists[position() = last()]"/>
</xsl:template>

<xsl:template mode="v2-body" match="SlidePersistAtom">
  <xsl:variable name="persist" select="."/>
  <xsl:variable name="id" select="@psrReference"/>
  <xsl:variable name="pr" select="$persist-refs[@id = $id]"/>
  <xsl:variable name="slide" select="$slides[@start = $pr/@offset]"/>

  <xsl:for-each select="$slide//msofbtClientTextbox">
    <xsl:apply-templates select="." mode="text"/>
    <xsl:for-each select=".//OutlineTextRefAtom">
      <xsl:variable name="instance" select="@ref"/>
      <xsl:apply-templates select="$persist//TextHeaderAtom[@instance = $instance]/*" mode="text"/>
    </xsl:for-each>
  </xsl:for-each>
  <hr/>
</xsl:template>
    

<!-- VERSION 1 -->

<xsl:template name="version-1">
  <xsl:variable name="slides" select="//Document//SlideListWithText[TextHeaderAtom]" />
  <xsl:variable name="slide" select="$slides[position() = last()]" />
  <xsl:apply-templates mode="v1-body" select="$slide" />
</xsl:template>

<xsl:template mode="v1-body" match="TextCharsAtom|TextBytesAtom|CString">
  <xsl:apply-templates mode="text" select="."/>
</xsl:template>

<xsl:template mode="v1-body" match="*">
  <xsl:apply-templates mode="v1-body" select="*" />
</xsl:template>

<xsl:template mode="v1-body" match="SlidePersistAtom">
  <hr />
</xsl:template>
]]></parser></converter><converter type-in="application/vnd.lotus-1-2-3" type-out="application/vnd.lotus-1-2-3-text" timing-name="Lotus 1-2-3"><converter-execute><![CDATA[vstrings --window 4 --min-char-pct 1 --min-space-pct 0 %source_file]]></converter-execute></converter><converter type-in="application/vnd.lotus-1-2-3-text" type-out="text/plain" timing-name="Lotus 1-2-3"><parser type="regex-text"><match token="^[8DP\\]?['\^&quot;]" goto="keep" /><state name="keep"><match token="$[8DP\\]?['\^&quot;]" goto="keep"><add-string><![CDATA[; ]]></add-string></match><match token="$" goto="discard" /><add-string /></state><state name="discard"><match token="^[8DP\\]?['\^&quot;]" goto="keep"><add-string><![CDATA[; ]]></add-string></match></state></parser></converter><converter type-in="outlook/mail" type-out="text/mailbox" elt-id="2055" timing-name="PST (Outlook) to mailbox"><converter-execute><![CDATA[%bin/readpst -w -r -o %target_dir %source_file > /dev/null]]></converter-execute></converter><converter type-in="text/mailbox" type-out="text/mail" elt-id="2057" timing-name="Mailbox to messages"><converter-execute><![CDATA[%bin/split-mail %target_dir]]></converter-execute></converter><converter type-in="text/mail" type-out="vivisimo/crawl-data" elt-id="2059" timing-name="Email message"><converter-execute><![CDATA[%bin/mail2vxml --parser vse-cache-parser-email --anchor %anchor 'snippet' 'subject=title' '*date' '*from' '*to' '*cc']]></converter-execute></converter><converter type-in="application/documentum" type-out="application/vxml-unnormalized" elt-id="2062" timing-name="vse-converter-documentum-to-xml" /><converter type-in="application/eroom" type-out="application/vxml-unnormalized" elt-id="2064" timing-name="eRoom documents"><parser type="xsl"><![CDATA[
  <xsl:variable name="action"><![CDATA[viv:choose($name = 'title' or $name = 'description','cluster', 'none')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[viv:choose($name = 'title',3,1)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="type"><![CDATA[viv:choose($name = 'title' or $name='snippet','html','text')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[false()]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[viv:choose(@name = 'Name', 'title', @name = 'Description', 'snippet', @name = 'ModifyDate', 'last-modified', @name)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[viv:choose($name = 'last-modified', concat(date:month-name(.), ' ',date:day-in-month(.),', ',date:year(.)))]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <vce>
    <xsl:apply-templates/>
  </vce>
</xsl:template>

<xsl:template match="vce">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:apply-templates select="*"/>
  </xsl:copy>
</xsl:template>


<xsl:template match="document">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates select="content"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:variable name="name" select="dyn:evaluate($mapping)"/>
  <xsl:variable name="a" select="dyn:evaluate($action)"/>
  <xsl:variable name="w" select="dyn:evaluate($weight)"/>
  <xsl:variable name="t" select="dyn:evaluate($type)"/>
  <xsl:variable name="oa" select="dyn:evaluate($output-action)"/>
  <xsl:variable name="vm" select="dyn:evaluate($value-mapping)"/> 
  <xsl:if test="$name">
  <content>
    <xsl:copy-of select="@*"/>
    <xsl:attribute name="name"><xsl:value-of select="$name"/></xsl:attribute>
    <xsl:if test="$a">
      <xsl:attribute name="action"><xsl:value-of select="$a"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$w">
      <xsl:attribute name="weight"><xsl:value-of select="$w"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$t">
      <xsl:attribute name="type"><xsl:value-of select="$t"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$oa">
      <xsl:attribute name="output-action"><xsl:value-of select="$oa"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$vm"><xsl:value-of select="$vm"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
  </xsl:if>
</xsl:template>



]]></parser></converter><converter type-out="application/vxml-unnormalized" type-in="application/lotus" elt-id="2066" timing-name="vse-converter-lotus-to-xml" /><converter type-in="application/sharepoint" type-out="application/vxml-unnormalized" elt-id="2068" timing-name="Sharepoint Documents"><parser type="xsl"><![CDATA[
  <xsl:variable name="action"><![CDATA[viv:choose($name = 'title' or $name = 'description','cluster', viv:match(@name, 'ows_.*Body')!='' or viv:match(@name, 'ows_.*PublishingPageContent')!='', 'none', viv:match(@name, 'Comment_.*')!='', 'index-only', @action, @action, 'none')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="weight"><![CDATA[viv:choose($name = 'title',3,1)]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="type"><![CDATA[viv:choose($name = 'title' or $name = 'snippet','html','text')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="output-action"><![CDATA[viv:choose($name = 'description' or $name = 'title' or $name = 'author', 'bold')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="mapping"><![CDATA[viv:choose(@name = 'Title' or @name = 'Description' or @name = 'Author', viv:str-to-lower(@name), @name = 'ows_Title' or @name = 'ows_Author' or viv:match(@name, 'ows_Comment_.*_Title')!='' or viv:match(@name, 'ows_Comment_.*_Author')!='', viv:str-to-lower(substring-after(@name, 'ows_')),  viv:match(@name, 'ows_.*Body')!='' or viv:match(@name, 'ows_.*PublishingPageContent')!='', 'snippet', @name = 'LastModified' or @name = 'ows_Modified', 'last-modified')]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="value-mapping"><![CDATA[dyn:evaluate(viv:choose($name='author' or viv:match($name, 'comment_.*_author')!='', "viv:replace(.,'^[[:digit:]]+;#','')"))]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <xsl:choose>
    <xsl:when test="viv:vivisimo-version-is-newer-than('5.0-5')">
      <vce>
        <xsl:apply-templates />
      </vce>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="v" select="viv:vivisimo-alloc()"/>
      <xsl:variable name="cn" select="viv:current-node(true())"/>
      <xsl:variable name="up" select="$cn/curl-options/curl-option[@name='user-password']"/>
      <xsl:variable name="xml">
        <declare name="no-recurse" initial-value="{viv:current-node()/@no-recurse}"/>
        <declare name="default-acl" initial-value="{viv:current-node()/@default-acl}"/>
        <call-function name="sharepoint-crawl">
          <with name="site-url"><xsl:value-of select="viv:replace($cn/@url,'\/*default.aspx$','')"/></with>
          <xsl:if test="$up">
            <with name="username"><xsl:value-of select="substring-before($up,':')"/></with>
            <with name="password"><xsl:value-of select="substring-after($up,':')"/></with>
          </xsl:if>
        </call-function>  
        <fetch timeout="300000" finish="finish"/>
      </xsl:variable>
      <xsl:value-of select="viv:vivisimo-input-xml($v, $xml)"/>
      <vce>
        <xsl:variable name="oxml" select="viv:vivisimo-xml($v)"/>
        <xsl:apply-templates select="$oxml//document"/>
        <xsl:for-each select="$oxml//crawl-url">
          <xsl:value-of select="viv:crawl-enqueue-url(false(),.)"/>
        </xsl:for-each>
      </vce>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="vce">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates/>
  </xsl:copy>
</xsl:template>



<xsl:template match="document">
  <xsl:copy>
    <xsl:copy-of select="@*[name(.)!='id']"/>
    <xsl:apply-templates select="content"/>
  </xsl:copy>
</xsl:template>

<xsl:template match="content">
  <xsl:variable name="name" select="dyn:evaluate($mapping)"/>
  <xsl:variable name="a" select="dyn:evaluate($action)"/>
  <xsl:variable name="w" select="dyn:evaluate($weight)"/>
  <xsl:variable name="t" select="dyn:evaluate($type)"/>
  <xsl:variable name="oa" select="dyn:evaluate($output-action)"/>
  <xsl:variable name="vm" select="dyn:evaluate($value-mapping)"/> 
  <xsl:if test="$name">
  <content>
    <xsl:copy-of select="@*"/>
    <xsl:attribute name="name"><xsl:value-of select="$name"/></xsl:attribute>
    <xsl:if test="$a">
      <xsl:attribute name="action"><xsl:value-of select="$a"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$w">
      <xsl:attribute name="weight"><xsl:value-of select="$w"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$t">
      <xsl:attribute name="type"><xsl:value-of select="$t"/></xsl:attribute>
    </xsl:if>
    <xsl:if test="$oa">
      <xsl:attribute name="output-action"><xsl:value-of select="$oa"/></xsl:attribute>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$vm"><xsl:value-of select="$vm"/></xsl:when>
      <xsl:otherwise><xsl:apply-templates select="*|text()"/></xsl:otherwise>
    </xsl:choose>
  </content>
  </xsl:if>
</xsl:template>

]]></parser></converter><converter type-in="application/word" type-out="text/html" elt-id="2070" timing-name="Microsoft Word to HTML"><converter-execute><![CDATA[%bin/wvWare -1 -x %bin/wvHtml.xml %source_file]]></converter-execute></converter><converter type-in="application/excel" type-out="text/html" elt-id="2072" timing-name="Microsoft Excel"><converter-execute><![CDATA[%bin/xlhtml -te %source_file]]></converter-execute></converter><converter type-in="application/wordperfect" type-out="text/html" elt-id="2074" timing-name="WordPerfect to HTML"><converter-execute><![CDATA[%bin/wpd2html %source_file > %target_file]]></converter-execute></converter><converter type-in="application/openoffice" type-out="text/html" elt-id="2076" timing-name="Open Office to HTML"><converter-execute><![CDATA[unzip -pq %source_file content.xml meta.xml | o3tohtml > %target_file]]></converter-execute></converter><converter type-in="application/vnd.ms-project" type-out="application/vxml-unnormalized" elt-id="2078" timing-name="Microsoft Project"><converter-execute><![CDATA[mpp2vxml --content-name snippet  %source_file]]></converter-execute></converter><converter type-in="application/ps" type-out="text/plain" elt-id="2080" timing-name="Postscript (ps) to text"><converter-execute><![CDATA[echo "<!-- Conversion of Postscript files is not currently supported -->" > %target_file]]></converter-execute></converter><converter type-in="application/pdf" type-out="text/html" elt-id="2082" timing-name="PDF to HTML"><converter-execute><![CDATA[%bin/pdftohtml -enc UTF-8 -i -noframes -c -stdout  %source_file | %bin/check-and-fix-utf8  | %bin/fix-pdf > %target_file]]></converter-execute></converter><converter type-in="application/rtf" type-out="text/html" elt-id="2084" timing-name="RTF to HTML"><converter-execute><![CDATA[%bin/rtf2html %source_file]]></converter-execute></converter><converter type-in="application/outlook-msg" type-out="vivisimo/crawl-data" elt-id="2086" timing-name="Email: Outlook (MSG) "><converter-execute><![CDATA[%bin/msg2vxml --cache-parser vse-cache-parser-email %source_file]]></converter-execute></converter><converter type-in="application/flash" type-out="text/html" elt-id="2088" timing-name="Flash to HTML"><converter-execute><![CDATA[echo "<!-- Conversion of Flash files is not currently supported -->" > %target_file]]></converter-execute></converter><converter type-in="application/tar" type-out="unknown" elt-id="2090" timing-name="TAR archive extractor"><converter-execute><![CDATA[
tar xf %source_file --no-same-owner --force-local --no-same-permissions --directory=%target_dir  > /dev/null && chmod -R +rwx %target_dir]]></converter-execute></converter><converter type-in="application/x-gzip" type-out="unknown" elt-id="2092" timing-name="Uncompress gzip (.gz)"><converter-execute><![CDATA[gunzip -f < %source_file > %target_file]]></converter-execute></converter><converter type-in="application/zip" type-out="unknown" elt-id="2094" timing-name="Uncompress ZIP files"><converter-execute><![CDATA[unzip -o %source_file -d %target_dir && chmod -R +rwx %target_dir]]></converter-execute></converter><converter type-in="application/x-compress" type-out="unknown" elt-id="2096" timing-name="Uncompress compress (.Z) files"><converter-execute><![CDATA[gunzip -f < %source_file > %target_file]]></converter-execute></converter><converter type-in="text/html" type-out="application/vxml-unnormalized" elt-id="2098" timing-name="HTML to XML"><parser type="html-xsl"><![CDATA[
  <xsl:variable name="meta-names"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="meta-action"><![CDATA[cluster-bold]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="ignore-robots"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="disable-title-extraction"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="disable-link-extraction"><![CDATA[]]]><![CDATA[]></xsl:variable>

<!--

Convert HTML to Vivisimo XML.

This XSL stylesheet does two things.  First it selects a title for the
page.  If the page is a PDF, Word, Powerpoint or Excel document, we will
consider replacing the title in the document.  The title selection is
based on looking for large fonts near the start of the document.  You
can explore this transformation and customize it as you see fit.

The second thing that this XSLT does is to take a subset of the HTML and
put it into a content named snippet.  Near the end of this parser, there
are a series of template matches that decide which tags will be placed
into the content, which will be discard and which will be discarded along
with their sub-nodes.

-->

<xsl:output method="xml" encoding="utf-8" />
<xsl:strip-space elements="*" />
<xsl:preserve-space elements="span" />

<xsl:variable name="include-alts">
</xsl:variable>

<!-- useful short-cuts -->

<xsl:variable name="filetypes" select="viv:current-node(true())/crawl-data/@filetypes"/>
<xsl:variable name="last-filetype" select="viv:replace(viv:replace($filetypes, '^html ', ''), ' .*', '')"/>
<xsl:variable name="generator" select="/html/head/meta[@name = 'GENERATOR']" />
<xsl:variable name="is-pdf" select="$last-filetype = 'pdf' or viv:test($url, '\.pdf$|\.pdf#', 'cregex')" />
<xsl:variable name="is-doc" select="starts-with($generator/@content, 'wvWare/wvWare')" />
<xsl:variable name="is-docx" select="starts-with($generator/@content, 'wpmltohtml')" />
<xsl:variable name="is-ppt" select="$last-filetype = 'ppt' or viv:test($url, '\.pp[st]$|\.pp[st]#', 'cregex')" />
<xsl:variable name="is-pptx" select="starts-with($generator/@content, 'pmltohtml')" />
<xsl:variable name="is-excel" select="$generator/@content = 'xlhtml'" />
<xsl:variable name="bad-title" select="$is-pdf or $is-doc or $is-docx or $is-ppt or $is-pptx" />

<!-- main match -->

<xsl:template match="/">
  <document>
    <xsl:variable 
      name="ver60" 
      select="viv:vivisimo-version()='6.0-1' or (function-available('viv:supported') and viv:supported('html-converter-link-extractor'))"/>

    <xsl:if test="$ver60 and ($ignore-robots or not(//meta[@name='robots' and (contains(@content, 'nofollow') or contains(@content, 'none'))])) and not($disable-link-extraction)">
      <xsl:call-template name="extract-links" />
    </xsl:if>
    <xsl:if test="not($ver60) or ($ignore-robots or not(//meta[@name='robots' and (contains(@content, 'noindex') or contains(@content, 'none'))]))">
      <xsl:if test="not($disable-title-extraction)">
        <xsl:call-template name="select-title" />
      </xsl:if>
      <xsl:call-template name="process-meta" />
      <xsl:variable name="body" select="/*"/>

      <xsl:variable name="keep-mode" select="not($is-pdf or $is-doc or $is-docx or $is-ppt or $is-pptx or $is-excel) and /*/*[@before-keep or @after-keep][1]" />
      <xsl:if test="$keep-mode">
        <content name="pre-snippet" weight="0.1" output-action="summarize" type="html">
          <xsl:apply-templates select="viv:if-else($body, $body, /*)" 
           mode="x"
          >
            <xsl:with-param name="keep" select="1"/>
          </xsl:apply-templates>
        </content>
      </xsl:if>

      <content name="snippet" weight="1" output-action="summarize" type="html">
        <xsl:apply-templates select="viv:if-else($body, $body, *|text())" mode="x" >
          <xsl:with-param name="keep" select="viv:if-else($keep-mode, 2, 0)"/>
        </xsl:apply-templates>
      </content>

      <xsl:if test="$keep-mode">
        <content name="post-snippet" weight="0.1" output-action="summarize" type="html">
          <xsl:apply-templates select="viv:if-else($body, $body, *|text())" 
           mode="x"
          >
            <xsl:with-param name="keep" select="3"/>
          </xsl:apply-templates>
        </content>
      </xsl:if>
    </xsl:if>
  </document>
</xsl:template>

<xsl:template match="text()" />

<!-- Meta tag handling -->

<xsl:template name="process-meta">
  <xsl:if test="$meta-names">
    <xsl:apply-templates select="/*/head//meta" mode="metas"/>
  </xsl:if>
</xsl:template>

<xsl:template match="meta" mode="metas">
  <xsl:variable name="n" select="viv:str-to-lowercase(normalize-space(@name))"/>
  <xsl:variable name="t" select="normalize-space(@content)" />

  <xsl:if test=
   "$t and $t != '' and $n and viv:test($n, $meta-names, 'wc-set')"
  >
    <content name="{$n}" action="{$meta-action}" type="text"
      weight="{1}"
    >
      <xsl:value-of select="$t" />
    </content>
  </xsl:if>
</xsl:template>


  <xsl:variable name="base" select="viv:if-else(/html/head/base/@href, /html/head/base/@href, $crawl-url-url)"/>

  <!-- Link extraction -->
  <xsl:template match="text()" mode="extract-links"/>

  <xsl:template name="extract-links">
    <xsl:if test="not(viv:test($url, 'file:*', 'wc'))">
      <xsl:apply-templates select="*" mode="extract-links" />
    </xsl:if>
  </xsl:template>

  <xsl:template match="link[not(viv:str-to-lower(@rel) = 'stylesheet' or viv:str-to-lower(@rel) = 'shortcut icon')]" mode="extract-links">
    <xsl:variable name="extra-crawl-url">
      <crawl-url obey-no-follow="obey-no-follow" />
    </xsl:variable>
    <xsl:value-of select="viv:crawl-enqueue-url(viv:url-resolve-base(viv:replace(@href, '^[[:space:]]+|[[:space:]]+$', '', 'g'), $base), $extra-crawl-url)" />
  </xsl:template>

  <xsl:template match="a[@href]|area[@href]" mode="extract-links">
    <xsl:variable name="extra-crawl-url">
      <crawl-url obey-no-follow="obey-no-follow" />
    </xsl:variable>
    <xsl:value-of select="viv:crawl-enqueue-url(viv:url-resolve-base(viv:replace(@href, '^[[:space:]]+|[[:space:]]+$', '', 'g'), $base), $extra-crawl-url)" />
    <xsl:apply-templates select="*" mode="extract-links" />
  </xsl:template>

  <xsl:template match="frame[@src]|embed[@src]|iframe[@src]" mode="extract-links">
    <xsl:variable name="extra-crawl-url">
      <crawl-url obey-no-follow="obey-no-follow" />
    </xsl:variable>
    <xsl:value-of select="viv:crawl-enqueue-url(viv:url-resolve-base(viv:replace(@src, '^[[:space:]]+|[[:space:]]+$', '', 'g'), $base), $extra-crawl-url)" />
    <xsl:apply-templates select="*" mode="extract-links" />
  </xsl:template>

  <xsl:template match="meta[@http-equiv]" mode="extract-links">
    <xsl:variable name="extra-crawl-url">
      <crawl-url obey-no-follow="obey-no-follow" />
    </xsl:variable>

    <xsl:if test="@http-equiv = 'refresh'">
      <xsl:variable name="content" select="@content" />
      <xsl:variable name="urlpart" select="viv:replace(substring-after($content, ';'), '^[[:space:]]+|[[:space:]]+$', '', 'g')" />

      <xsl:if test="viv:test($urlpart, 'url.*', 'case-insensitive-regex')">
        <xsl:variable name="url" select="substring($urlpart, 5)" />

        <xsl:value-of select="viv:crawl-enqueue-url(viv:url-resolve-base(viv:replace($url, '^[[:space:]]+|[[:space:]]+$', '', 'g'), $base), $extra-crawl-url)" />
      </xsl:if>
    </xsl:if>
  </xsl:template>


<!-- Title extraction -->

<xsl:template name="select-title">
  <xsl:variable name="t0" select="//title[normalize-space(.) != '']" />
  <!-- check if user xpath was successful, if not, fall back to default expression -->
  <xsl:variable name="t1" select="viv:if-else(string-length($t0) &gt; 0,$t0,//title[normalize-space(.) != ''])" />
  <xsl:variable name="t" select="viv:replace(viv:replace($t1, '^Microsoft Word - ', ''), '\.doc$', '')"/>
  <xsl:choose>
    <xsl:when test="$is-excel">
      <xsl:variable name="title"
        select="normalize-space(viv:concat(//h1[1]//text(), ' '))"
      />
      <xsl:if test="not(viv:test($title, '^Sheet[1-9][0-9]*$', 'regex'))">
        <content name="title" output-action="bold" weight="3" type="html">
          <xsl:value-of select="$title"/>
        </content>
      </xsl:if>
    </xsl:when>
    <xsl:when test="$bad-title">
      <xsl:call-template name="conditional-title-extractor">
        <xsl:with-param name="title" select="$t"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$t">
      <content name="title" output-action="bold" weight="3" type="html">
        <xsl:value-of select="$t"/>
      </content>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template name="conditional-title-extractor">
  <xsl:param name="title" select="//title" />

  <xsl:variable name="spans" select="//span" />
  <xsl:variable name="t-title" select="str:tokenize($title)" />

  <xsl:choose>
    <xsl:when test="string-length(normalize-space($title)) > 3">
      <xsl:call-template name="find-title-words">
        <xsl:with-param name="spans" select="$spans[position() &lt;= 100]" />
        <xsl:with-param name="title" select="$title" />
        <xsl:with-param name="t-title" select="$t-title" />
        <xsl:with-param name="pos" select="1" />
        <xsl:with-param name="may-miss" select="floor(count($t-title) div 4)" />
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$spans">
      <xsl:call-template name="generate-title">
        <xsl:with-param name="spans" select="$spans[position() &lt;= 100]" />
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template name="find-title-words">
  <xsl:param name="spans" />
  <xsl:param name="title" />
  <xsl:param name="t-title" />
  <xsl:param name="pos" />
  <xsl:param name="may-miss" />

  <xsl:choose>
    <xsl:when test="$pos > 0 and $pos > count($t-title)">
      <!-- found all title words, keep this title -->
      <content name="title" output-action="bold" weight="3" type="html">
        <xsl:value-of select="$title" />
      </content>
    </xsl:when>
    <xsl:when test="$pos &lt;= count($t-title) and $spans[viv:test(., concat('*', viv:replace($t-title[position() = $pos], '[[:punct:]]', '', 'g'), '*'), 'wc')]">
      <!-- found this title word, look for the next one -->
      <xsl:call-template name="find-title-words">
        <xsl:with-param name="spans" select="$spans" />
        <xsl:with-param name="title" select="$title" />
        <xsl:with-param name="t-title" select="$t-title" />
        <xsl:with-param name="pos" select="$pos + 1" />
        <xsl:with-param name="may-miss" select="$may-miss" />
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$may-miss > 0">
      <xsl:call-template name="find-title-words">
        <xsl:with-param name="spans" select="$spans" />
        <xsl:with-param name="title" select="$title" />
        <xsl:with-param name="t-title" select="$t-title" />
        <xsl:with-param name="pos" select="$pos + 1" />
        <xsl:with-param name="may-miss" select="$may-miss - 1" />
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <!-- no match for this word, generate a title -->
      <xsl:call-template name="generate-title">
        <xsl:with-param name="spans" select="$spans" />
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="generate-title">
  <xsl:param name="spans" />

  <content name="title" output-action="bold" weight="3" type="html">
    <xsl:choose>
      <xsl:when test="$is-pdf">
        <xsl:call-template name="pdf-title-extractor">
          <xsl:with-param name="spans" select="$spans" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$is-doc">
        <xsl:call-template name="doc-title-extractor">
          <xsl:with-param name="spans" select="$spans" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$is-docx">
        <xsl:call-template name="doc-title-extractor">
          <xsl:with-param name="spans" select="$spans" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$is-ppt">
        <xsl:call-template name="doc-title-extractor">
          <xsl:with-param name="spans" select="$spans[position() &lt;= 10]" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$is-pptx">
        <xsl:call-template name="doc-title-extractor">
          <xsl:with-param name="spans" select="$spans[position() &lt;= 10]" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </content>
</xsl:template>

<!-- DOC/PPT title extractor -->

<xsl:template name="doc-title-extractor">
  <xsl:param name="spans" />

  <xsl:variable name="sizes-str">
    <xsl:apply-templates select="$spans" mode="doc-emit-sizes">
      <xsl:sort select="number(substring-before(substring-after(@style, 'font-size: '), 'pt'))" data-type="number" order="descending" />
    </xsl:apply-templates>
  </xsl:variable>

  <xsl:variable name="sizes" select="str:tokenize($sizes-str)" />

  <xsl:call-template name="doc-title-size">
    <xsl:with-param name="spans" select="$spans" />
    <xsl:with-param name="sizes" select="$sizes" />
    <xsl:with-param name="pos" select="1" />
  </xsl:call-template>
</xsl:template>

<xsl:template name="doc-title-size">
  <xsl:param name="spans" />
  <xsl:param name="sizes" />
  <xsl:param name="pos" />

  <xsl:variable name="pt" select="$sizes[position() = $pos]" />
  <xsl:if test="$pos &lt;= count($sizes)">
    <xsl:choose>
      <xsl:when test="$pos = 1 or $pt != $sizes[position() = $pos - 1]">

        <xsl:variable name="positions-str">
          <xsl:apply-templates select="$spans" mode="doc-positions">
            <xsl:with-param name="pt" select="$pt" />
          </xsl:apply-templates>
        </xsl:variable>
        <xsl:variable name="positions" select="str:tokenize($positions-str)" />
        <xsl:variable name="position0" select="$positions[1]" />
        <xsl:variable name="s" select="$spans[substring-before(substring-after(@style, 'font-size: '), 'pt') = $pt and position() &lt;= $position0 + 10]" />

        <xsl:choose>
          <xsl:when test="$s//text()[string-length(normalize-space(.)) >= 5]">
            <xsl:call-template name="output-title-strings">
              <xsl:with-param name="text" select="$s" />
              <xsl:with-param name="pos" select="1" />
            </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="doc-title-size">
              <xsl:with-param name="spans" select="$spans" />
              <xsl:with-param name="sizes" select="$sizes" />
              <xsl:with-param name="pos" select="$pos + 1" />
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="doc-title-size">
          <xsl:with-param name="spans" select="$spans" />
          <xsl:with-param name="sizes" select="$sizes" />
          <xsl:with-param name="pos" select="$pos + 1" />
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template>

<xsl:template match="*" mode="doc-positions">
  <xsl:param name="pt" />
  <xsl:if test="substring-before(substring-after(@style, 'font-size: '), 'pt') = $pt">
    <xsl:value-of select="position()" />
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template>

<xsl:template mode="doc-emit-sizes" match="*">
  <xsl:value-of select="substring-before(substring-after(@style, 'font-size: '), 'pt')" /><xsl:text> </xsl:text>
</xsl:template>

<!-- PDF title extractor -->

<xsl:template name="pdf-title-extractor">
  <xsl:param name="spans" />

  <!-- make sure we don't try to extract a title from a blank page,
       look for pages that have at least one div on them.
    -->
  <xsl:variable name="pages" select="/*/*/div[div]" />
  <xsl:if test="$pages">
    <xsl:variable name="style" select="viv:if-else($pages[1]/style/comment(), $pages[1]/style/comment(), $pages[1]/style)"/>
    <xsl:variable name="css" select="str:tokenize(viv:replace(viv:replace($style,'\{[^}]*font-size: *', ',', 'g'),'px[^}]*} *', '', 'g'), '&#10;')" />

    <xsl:variable name="biggest-str">
      <xsl:apply-templates select="$css" mode="strip-tags">
        <xsl:sort select="number(substring-after(text(), ','))" data-type="number" order="descending" />
      </xsl:apply-templates>
    </xsl:variable>
    <xsl:variable name="biggest" select="str:tokenize($biggest-str, ' ')" />
    <xsl:call-template name="pdf-title-size">
      <xsl:with-param name="sizes" select="$biggest" />
      <xsl:with-param name="pos" select="1" />
      <xsl:with-param name="spans" select="$spans" />
    </xsl:call-template>
  </xsl:if>
</xsl:template>

<xsl:template name="pdf-title-size">
  <xsl:param name="sizes" />
  <xsl:param name="pos" />
  <xsl:param name="spans" />

  <xsl:if test="$pos &lt;= count($sizes)">
    <xsl:variable name="this" select="$sizes[position() = $pos]" />
    <xsl:variable name="size" select="substring-after($this, ',')" />
    <xsl:variable name="classes" select="$sizes[substring-after(., ',') = $size]" />

    <xsl:variable name="class-condition">
      false()
      <xsl:for-each select="$classes">
        or @class = '<xsl:value-of select="substring-after(substring-before(., ','), '.')" />'
      </xsl:for-each>
    </xsl:variable>

    <xsl:variable name="positions-str">
      <xsl:apply-templates select="$spans" mode="pdf-positions">
        <xsl:with-param name="class-condition" select="$class-condition" />
      </xsl:apply-templates>
    </xsl:variable>
    <xsl:variable name="positions" select="str:tokenize($positions-str)" />
    <xsl:variable name="position0" select="$positions[1]" />
    <xsl:variable name="s" select="dyn:evaluate(concat('$spans[position() &lt;= $position0 + 10 and (', $class-condition, ')]'))" />

    <xsl:choose>
      <xsl:when test="count($classes) = 0">
        <!-- will go into an infinite loop doing nothing -->
      </xsl:when>
      <xsl:when test="not(str:split(viv:concat($s//text()))[string-length(text())
> 1])">
        <xsl:call-template name="pdf-title-size">
          <xsl:with-param name="sizes" select="$sizes" />
          <xsl:with-param name="pos" select="$pos + count($classes)" />
          <xsl:with-param name="spans" select="$spans" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$s//text()[string-length(normalize-space(.)) >= 5]">
        <xsl:call-template name="output-title-strings">
          <xsl:with-param name="text" select="$s" />
          <xsl:with-param name="pos" select="1" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$classes">
        <xsl:call-template name="pdf-title-size">
          <xsl:with-param name="sizes" select="$sizes" />
          <xsl:with-param name="pos" select="$pos + count($classes)" />
          <xsl:with-param name="spans" select="$spans" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:if>
</xsl:template>

<xsl:template match="*" mode="pdf-positions">
  <xsl:param name="class-condition" />
  <xsl:if test="dyn:evaluate($class-condition)">
    <xsl:value-of select="position()" />
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template>

<xsl:template name="output-title-strings">
  <xsl:param name="text" />
  <xsl:param name="pos" />
  <xsl:param name="limit" select="viv:if-else($is-ppt or $is-pptx, 1, 100)" />
  <xsl:param name="bytes-output" select="0" />
  <xsl:param name="last-s" select="''" />

  <xsl:variable name="s">
    <xsl:for-each select="$text[position() = $pos]//text()">
      <xsl:value-of select="normalize-space(.)" />
      <xsl:text> </xsl:text>
    </xsl:for-each>
  </xsl:variable>

  <xsl:if test="string-length($s) &lt;= $limit or  5*$bytes-output &lt; $limit">

    <xsl:variable name="display-s">
      <xsl:if test="$s != $last-s">
        <xsl:value-of select="$s" />
      </xsl:if>
    </xsl:variable>

    <xsl:value-of select="$display-s" />

    <xsl:if test="$pos &lt; count($text)">
      <xsl:call-template name="output-title-strings">
        <xsl:with-param name="text" select="$text" />
        <xsl:with-param name="pos" select="$pos + 1" />
        <xsl:with-param name="limit" select="$limit - string-length($display-s)" />
        <xsl:with-param name="bytes-output" select="$bytes-output + string-length($display-s)" />
        <xsl:with-param name="last-s" select="$s" />
      </xsl:call-template>
    </xsl:if>
  </xsl:if>
</xsl:template>

<xsl:template match="text()" mode="strip-tags">
  <xsl:value-of select="." /><xsl:text> </xsl:text>
</xsl:template>

<xsl:template mode="x" match="*">
  <xsl:param name="keep"/>
  <xsl:if test="@alt">
    <xsl:apply-templates select="." mode="check-alt">
      <xsl:with-param name="keep" select="$keep"/>
    </xsl:apply-templates>
  </xsl:if>
  <xsl:choose>
    <xsl:when test="(name() = 'span' or name() = 'b' or name() = 'i' or name() = 'u' or name() = 's' or name() = 'sup' or name() = 'sub' or name() = 'blink' or name() = 'font') and ($is-doc or $is-docx )"/>
    <xsl:otherwise>
  <xsl:text> </xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:apply-templates mode="x">
    <xsl:with-param name="keep" select="$keep"/>
  </xsl:apply-templates>
  <xsl:choose>
    <xsl:when test="(name() = 'span' or name() = 'b' or name() = 'i' or name() = 'u' or name() = 's' or name() = 'sup' or name() = 'sub' or name() = 'blink' or name() = 'font') and ($is-doc or $is-docx )"/>
    <xsl:otherwise>
  <xsl:text> </xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template mode="x" match="font|span|div|td|a|h1|h2|h3|h4|h5|b|p|br|hr|li|option">
  <xsl:param name="keep"/>
  <xsl:if test="$keep = 0 or ($keep = 1 and @before-keep) or ($keep = 2 and @keep) or ($keep = 3 and @after-keep)">
    <xsl:if test="@alt">
      <xsl:apply-templates select="." mode="check-alt"/>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="(name() = 'br' and not($is-pdf)) or name() = 'hr' or name() = 'p'">
        <xsl:apply-templates mode="show-tag" select=".">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:when test="true() or text()[string-length(.) > 10 or normalize-space(.) != '']">
        <xsl:apply-templates mode="show-tag" select=".">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="x">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template>

<xsl:template mode="x" match="title|head|meta|script|style">
  <xsl:choose>
    <xsl:when test="(name() = 'span' or name() = 'b' or name() = 'i' or name() = 'u' or name() = 's' or name() = 'sup' or name() = 'sub' or name() = 'blink' or name() = 'font') and ($is-doc or $is-docx )"/>
    <xsl:otherwise>
  <xsl:text> </xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template mode="show-tag" match="*">
  <xsl:param name="keep"/>

  <xsl:variable name="keeping" select="
      $keep = 0 or 
      (
        ( $keep = 1 and @before-keep ) or
        ( $keep = 3 and @after-keep   ) or
        ( $keep = 2 and not(@before-keep or @after-keep) )
      )
  "/>

    <xsl:if test="@alt and $keeping">
      <xsl:apply-templates select="." mode="check-alt"/>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="(name() = 'span' or name() = 'b' or name() = 'i' or name() = 'u' or name() = 's' or name() = 'sup' or name() = 'sub' or name() = 'blink' or name() = 'font') and ($is-doc or $is-docx )">
        <!-- spans are purely font information for word documents, don't keep
             them. -->
        <xsl:apply-templates mode="x">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:when test="node()">
        <xsl:if test="$keeping">
          <xsl:value-of select="concat('&lt;', name(), '>')"/>
        </xsl:if>
        <xsl:apply-templates mode="x">
          <xsl:with-param name="keep" select="$keep"/>
        </xsl:apply-templates>
        <xsl:if test="$keeping">
          <xsl:value-of select="concat('&lt;/', name(), '>')"/>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="$keeping">
          <xsl:value-of select="concat('&lt;', name(), '/>')"/>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>

</xsl:template>

<xsl:template mode="x" match="@*"/>

<!-- Otherwise, print the text.  Remove extra white space to make it
     easier to read.
  -->

<xsl:template mode="x" match="text()">
  <xsl:param name="keep"/>

  <xsl:if test="
      $keep = 0 or 
      (
        ( $keep = 1 and ../@before-keep ) or
        ( $keep = 3 and ../@after-keep   ) or
        ( $keep = 2 and not(../@before-keep or ../@after-keep) )
      )
  ">
   <xsl:value-of select="viv:node-to-str(.)" />
  </xsl:if>
</xsl:template>

<xsl:template mode="check-alt" match="a|img">
  <xsl:if test="$include-alts and @alt and normalize-space(@alt) != ''">
    <xsl:text> </xsl:text>
    <xsl:value-of select="viv:node-to-str(exsl:node-set(string(@alt)))"/>
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template>


]]></parser></converter><converter type-in="text/plain" type-out="application/vxml-unnormalized" elt-id="2100" timing-name="Text to XML"><macro name="vse-converter-text-content"><add-content type="text"><attribute name="name"><value-of-var name="name" /></attribute><if-var name="action"><attribute name="action"><value-of-var name="action" /></attribute></if-var><if-var name="type"><attribute name="type"><value-of-var name="type" /></attribute></if-var><if-var name="output-action"><attribute name="output-action"><value-of-var name="output-action" /></attribute></if-var><if-var name="weight"><attribute name="weight"><value-of-var name="weight" /></attribute></if-var></add-content></macro><parser name="text2vxml"><match token="^" goto="start"><add-document /></match><state name="start"><match token="..*" goto="more"><add-content type="text" name="snippet" /></match></state><state name="more"><match token="..*" goto="more"><prepend token=" " /><add-content type="text" name="snippet" /></match></state></parser></converter><converter type-in="unknown" type-out="application/dbf" elt-id="2102"><converter-test how="wc-set" what="path" elt-id="2103"><![CDATA[*.dbf]]></converter-test></converter><converter type-in="application/dbf" type-out="text/csv" elt-id="2104" timing-name="DBF to CSV"><converter-execute><![CDATA[dbf --csv - %source_file | iso2utf > %target_file]]></converter-execute></converter><converter type-in="text/csv" type-out="application/vxml-unnormalized" elt-id="2106" timing-name="CSV to VXML"><converter-execute><![CDATA[%bin/csv2vxml %source_file]]></converter-execute></converter><converter type-in="text/xml" type-out="application/vxml-unnormalized" elt-id="2108" timing-name="XML to Data Explorer XML"><parser type="xsl"><![CDATA[<xsl:template match="/">
  <document>
    <content name="snippet" output-action="summarize" type="text">
      <xsl:apply-templates select="*" mode="xml-to-plain-text" />
    </content>
  </document>
</xsl:template>

<xsl:template match="*" mode="xml-to-plain-text">
  <xsl:text><![CDATA[<]]]><![CDATA[]></xsl:text>
  <xsl:value-of select="name()" />
  <xsl:text> </xsl:text>
  <xsl:choose>
    <xsl:when test="text()|*|comment()">
      <xsl:text><![CDATA[>]]]><![CDATA[]></xsl:text>
      <xsl:apply-templates select="text()|*|comment()" mode="xml-to-plain-text" />
      <xsl:text><![CDATA[</]]]><![CDATA[]></xsl:text>
      <xsl:value-of select="name()" />
      <xsl:text><![CDATA[>]]]><![CDATA[]></xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text><![CDATA[/>]]]><![CDATA[]></xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>]]></parser></converter><converter type-in="application/vxml-unnormalized" type-out="application/vxml-unnormalized" elt-id="2110" timing-name="Normalization"><parser type="xsl"><![CDATA[
  <xsl:variable name="max-title-length"><![CDATA[120]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="url-ignore-protos"><![CDATA[db2|mysql|oracle|postgresql|sqlserver|sybase]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="url-weight"><![CDATA[1]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="url-action"><![CDATA[none]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="host-weight"><![CDATA[1]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="host-action"><![CDATA[none]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="file-size-name"><![CDATA[size]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="disable-attachment-filename"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="attachment-filename-weight"><![CDATA[1]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="date-bias-what"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="date-bias-xpath"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="last-modified"><![CDATA[true]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="last-modified-weight"><![CDATA[-1]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="crawled-date"><![CDATA[false]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="crawled-date-weight"><![CDATA[-1]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-detection"><![CDATA[true]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-contents"><![CDATA[title|snippet|description]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-required-contents"><![CDATA[snippet|description]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-content"><![CDATA[language]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-default"><![CDATA[unknown]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="min-language-bytes"><![CDATA[40]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="max-language-bytes"><![CDATA[50000]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-index-stream-enabled"><![CDATA[false]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-index-stream-min-bytes"><![CDATA[40]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-index-stream-contents"><![CDATA[*]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="language-index-stream-options"><![CDATA[<indexing-options><output-stream language="japanese"><vse-index-stream stem="depluralize" segmenter="japanese" kb="japanese-indexing" /></output-stream><output-stream language="chinese"><vse-index-stream stem="depluralize" segmenter="mixed" /></output-stream><output-stream language="thai"><vse-index-stream stem="depluralize" segmenter="thai" /></output-stream><output-stream language="korean"><vse-index-stream stem="depluralize" segmenter="korean"/></output-stream></indexing-options>]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="static-summary-names"><![CDATA[]]]><![CDATA[]></xsl:variable>

  <xsl:variable name="static-summary-bytes"><![CDATA[]]]><![CDATA[]></xsl:variable>


<xsl:template match="/">
  <vce>
    <xsl:apply-templates/>
  </vce>
</xsl:template>

<xsl:template match="vce">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="*">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates/>
  </xsl:copy>
</xsl:template>

<xsl:template match="document">
  <xsl:copy>
    <xsl:if test="viv:vivisimo-version() = '5.5-6'">
      <xsl:if test="viv:current-node()/@warning">
        <!-- bug in 5.5-6 that causes the warning attribute from the crawl-url
             node to the document when indexed. Make sure it doesn't end up in
             there.
          -->
        <xsl:attribute name="warning"/>
      </xsl:if>
    </xsl:if>
    <xsl:apply-templates select="@*[not(name() = $date-bias-what) and not(name() = 'file-types')]" />
    <xsl:if test="not(@url) and $url != $crawl-url-url">
      <xsl:attribute name="url"><xsl:value-of select="$url"/></xsl:attribute>
    </xsl:if>
    <xsl:apply-templates mode="document-attributes" select="."/>
    <xsl:call-template name="handle-date-bias" />
    <xsl:apply-templates mode="filetype" select="."/>
    <xsl:apply-templates mode="filesize" select="."/>
    <xsl:apply-templates mode="output-url-host" select="." />
    <xsl:apply-templates mode="attachment-filename" select="."/>
    <xsl:call-template name="output-dates" />
    <xsl:if test="$language-detection and $language-detection = 'true' and function-available('viv:classify-language')">
      <xsl:apply-templates mode="language" select="."/>
    </xsl:if>

    <xsl:apply-templates select="*"/>
    <xsl:apply-templates mode="document" select="." />
  </xsl:copy>
</xsl:template>

<xsl:template mode="filetype" match="document">
  <xsl:variable name="filetypes" select="set:distinct(str:tokenize(viv:current-node(true())/crawl-data/@filetypes, ' '))"/>

  <xsl:if test="count($filetypes) > 0">

    <xsl:variable name="new-filetypes">

      <xsl:for-each select="str:tokenize(str:padding(count($filetypes)), '')">
        <xsl:variable name="i" select="position()"/>
        <xsl:variable name="ft" select="$filetypes[position() = $i]"/>
        <xsl:variable name="ft-1" select="viv:if-else($i > 1, $filetypes[position() = $i - 1], '')"/>
        <xsl:choose>
          <xsl:when test="$ft = 'html' and viv:test($ft-1, 'doc|pdf|xls|wordperfect|openoffice|rtf|flash|ppt')"/>
          <xsl:when test="$ft = 'text' and viv:test($ft-1, 'ps|xls')"/>
          <xsl:otherwise><xsl:value-of select="$ft"/></xsl:otherwise>
        </xsl:choose>
        <xsl:text> </xsl:text>
      </xsl:for-each>

    </xsl:variable>

    <xsl:attribute name="filetypes">
      <xsl:value-of select="viv:replace($new-filetypes, '   *', ' ', 'g')"/>
    </xsl:attribute>

    <xsl:for-each select="str:tokenize($new-filetypes)">
      <content name="filetype" action="none" type="text"><xsl:value-of select="."/></content>
    </xsl:for-each>

  </xsl:if>
</xsl:template>

<xsl:template mode="filesize" match="document">
  <xsl:variable name="size" select="viv:current-node()/@size"/>
  <xsl:if test="$file-size-name != '' and $size > 0">
    <content name="{$file-size-name}" weight="-1" type="text">
      <xsl:value-of select="$size"/>
    </content>
  </xsl:if>
</xsl:template>

<xsl:template mode="output-url-host" match="document">
  <xsl:variable name="url0" select="viv:if-else(@url, @url, $url)"/>
  <xsl:variable name="url" select="viv:url-decompose($url0)"/>
  <xsl:if test="not(viv:test($url/protocol, $url-ignore-protos, 'wc-set'))">
    <xsl:call-template name="output-url-host-1">
      <xsl:with-param name="name" select="'url'"/>
      <xsl:with-param name="value" select="str:decode-uri($url0)"/>
      <xsl:with-param name="action" select="$url-action"/>
      <xsl:with-param name="weight" select="$url-weight"/>
    </xsl:call-template>
    <xsl:call-template name="output-url-host-1">
      <xsl:with-param name="name" select="'host'"/>
      <xsl:with-param name="value" select="$url/host"/>
      <xsl:with-param name="action" select="$host-action"/>
      <xsl:with-param name="weight" select="$host-weight"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template>

<xsl:template name="output-url-host-1">
  <xsl:param name="name"/>
  <xsl:param name="value"/>
  <xsl:param name="action"/>
  <xsl:param name="weight"/>

  <xsl:if test="$weight >= 0 and $value and $value != ''">
    <content name="{$name}" type="text">
      <xsl:if test="$weight != 1">
        <xsl:attribute name="weight">
          <xsl:value-of select="$weight"/>
        </xsl:attribute>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="$action = 'none'">
          <xsl:attribute name="action">none</xsl:attribute>
        </xsl:when>
        <xsl:when test="$action = 'index-only'">
          <xsl:attribute name="action">index-only</xsl:attribute>
        </xsl:when>
        <xsl:when test="$action = 'bold'">
          <xsl:attribute name="output-action">bold</xsl:attribute>
        </xsl:when>
      </xsl:choose>
      <xsl:value-of select="$value" />
    </content>
  </xsl:if>
</xsl:template>

<xsl:template mode="attachment-filename" match="document">
  <xsl:if test="not($disable-attachment-filename)">
    <xsl:variable name="cd" select="viv:current-node(true())/crawl-data"/>
    <xsl:if test="$cd/@attachment-filename">
      <content name="attachment-filename" weight="{$attachment-filename-weight}" action="none" type="text">
        <xsl:value-of select="$cd/@attachment-filename"/>
      </content>
    </xsl:if>
  </xsl:if>
</xsl:template>

<xsl:template match="content">

  <!-- Intelligent streams: if language detected is a language defined in the intelligent streams option XML, add the corresponding vse-index-stream to the content. -->
    <xsl:variable name="self" select="." />
    <xsl:variable name="c" select="$self[viv:test(@name, $language-index-stream-contents, 'wc-set')]"/>

  <xsl:variable name="indexing-stream">
    <xsl:if test="$language-index-stream-enabled and $language-index-stream-enabled='true' and not(vse-index-stream) and $c">

      <xsl:variable name="html"> 
        <xsl:call-template name="language-text"> 
          <xsl:with-param name="c" select="$c[not(@type) or @type != 'text']"/> 
        </xsl:call-template> 
      </xsl:variable>
 
      <xsl:variable name="text"> 
        <xsl:call-template name="language-text"> 
          <xsl:with-param name="c" select="$c[@type = 'text']"/> 
          <xsl:with-param name="len" select="string-length($html)"/> 
        </xsl:call-template> 
      </xsl:variable> 

      <xsl:variable name="len" select="string-length($html) + string-length($text)"/>
      <xsl:if test="($len >= $language-index-stream-min-bytes)"> 
        <xsl:variable name="l" select="viv:classify-language($html, 'html', $text, 'text')"/> 
        <xsl:variable name="liso" select="viv:str-to-node($language-index-stream-options)" />
        <xsl:if test="$liso/output-stream[viv:match($l, @language)]">
          <xsl:copy-of select="$liso/output-stream[viv:match($l, @language)]/vse-index-stream" />
        </xsl:if>
      </xsl:if>
    </xsl:if>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$static-summary-names and viv:test(@name, $static-summary-names, 'wc-set')">
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:attribute name="action">index-only</xsl:attribute>
        <xsl:apply-templates mode="content-attributes" select="."/>
        <xsl:copy-of select="$indexing-stream" />
        <xsl:copy-of select="vse-index-stream" />
        <xsl:apply-templates select="text()"/>
      </xsl:copy>
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:attribute name="indexed">false</xsl:attribute>
        <xsl:apply-templates mode="content-attributes" select="."/>
        <xsl:copy-of select="$indexing-stream" />
        <xsl:copy-of select="vse-index-stream" />
        <xsl:call-template name="chop">
          <xsl:with-param name="text" select="viv:if-else(@type = 'text', ., viv:replace(., '&lt;[^>]*>', ' ', 'g'))"/>
          <xsl:with-param name="max-length" select="viv:evaluate($static-summary-bytes)"/>
        </xsl:call-template>
      </xsl:copy>
    </xsl:when>
<!--<xsl:when test="$normalize-spaces and $normalize-spaces = 'true'">
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:copy-of select="normalize-space(.)"/>
      </xsl:copy>
    </xsl:when>
-->
    <xsl:otherwise>
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:if test="@name = 'title' and $max-title-length &lt;= 0">
          <xsl:attribute name="type">text</xsl:attribute>
        </xsl:if>
        <xsl:apply-templates mode="content-attributes" select="."/>
        <xsl:copy-of select="$indexing-stream" />
        <xsl:copy-of select="vse-index-stream" />
        <xsl:apply-templates select="text()"/>
      </xsl:copy>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:apply-templates mode="content" select="."/>
</xsl:template>

<xsl:template match="comment()|@*">
  <xsl:copy />
</xsl:template>

<xsl:template match="text()">
  <!-- remove all soft-hyphens --> 
  <xsl:value-of select="viv:replace(., '&#173;', '', 'g')" />
</xsl:template>


<!-- ******************************************* 
                 Language detection 
     ******************************************* --> 
<xsl:template mode="language" match="document"> 

    <xsl:variable name="c" select="content[viv:test(@name, $language-contents, 'wc-set')]"/>

    <xsl:variable name="html"> 
      <xsl:call-template name="language-text"> 
        <xsl:with-param name="c" select="$c[not(@type) or @type != 'text']"/> 
      </xsl:call-template> 
    </xsl:variable>
 
    <xsl:variable name="text"> 
      <xsl:call-template name="language-text"> 
        <xsl:with-param name="c" select="$c[@type = 'text']"/> 
        <xsl:with-param name="len" select="string-length($html)"/> 
      </xsl:call-template> 
    </xsl:variable> 

    <xsl:variable name="len" select="string-length($html) + string-length($text)"/>

    <!-- Not adding a language content when there is not enough text to make a reliable guess or when doc only has title (bug 10249 #20)-->

    <xsl:if test="($len >= $min-language-bytes) and ($c[viv:test(@name, $language-required-contents, 'wc-set')])"> 
      <xsl:variable name="l" select="viv:classify-language($html, 'html', $text, 'text')"/> 
      <content name="{$language-content}" weight="0" action="none" type="text"> 
        <xsl:value-of select="viv:if-else($l and $l != '', $l, $language-default)"/> 
      </content>
    </xsl:if>

</xsl:template> 

<xsl:template name="language-text">
<!-- Assuming that these are default params, in case they are not specified in the template call -->
  <xsl:param name="c" /> 
  <xsl:param name="i" select="1" /> 
  <xsl:param name="len" select="0" />

  <xsl:choose> 
    <xsl:when test="$i > count($c)"/> 
    <xsl:when test="$max-language-bytes &lt; 0"> 
	  <xsl:value-of select="$c[$i]"/> 
	    <xsl:call-template name="language-text"> 
	     <xsl:with-param name="c" select="$c"/> 
	     <xsl:with-param name="i" select="$i + 1"/> 
        </xsl:call-template> 
    </xsl:when>
    <xsl:when test="$len >= $max-language-bytes"/> 
    <xsl:otherwise> 
	 <xsl:variable name="contentlen" select="string-length($c[$i])"/> 
	 <xsl:value-of select="substring($c[$i], 1, $max-language-bytes - $len)"/> 
	  <xsl:call-template name="language-text"> 
	   <xsl:with-param name="c" select="$c"/> 
	   <xsl:with-param name="i" select="$i + 1"/> 
	   <xsl:with-param name="len" select="$len + $contentlen"/> 
      </xsl:call-template> 
    </xsl:otherwise> 
  </xsl:choose> 

</xsl:template> 

<!-- *******************************************
               Date bias
     ******************************************* -->

<xsl:template name="handle-date-bias">
  <xsl:variable name="at">
    <xsl:choose>
      <xsl:when test="$date-bias-xpath and number(dyn:evaluate($date-bias-xpath)) > 0">
        <xsl:value-of select="dyn:evaluate($date-bias-xpath)"/>
      </xsl:when>
      <xsl:when test="$crawl-url-last-modified and number($crawl-url-last-modified) > 0">
        <xsl:value-of select="$crawl-url-last-modified" />
      </xsl:when>
      <xsl:when test="$crawl-url-at and number($crawl-url-at) > 0">
        <xsl:value-of select="$crawl-url-at" />
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:if test="$date-bias-what != '' and $at and number($at) > 0">
    <xsl:attribute name="{$date-bias-what}">
      <xsl:value-of select="viv:if-else($date-bias-what != 'la-score', 1, 0) + (1 div ((date:seconds() - $at) div (60*60*24) + 1.5) * viv:if-else(@*[name() = $date-bias-what], @*[name() = $date-bias-what], 1))" />
    </xsl:attribute>
  </xsl:if>
</xsl:template>

<!-- *******************************************
               Output dates
     ******************************************* -->

<xsl:template name="output-dates">
  <xsl:if test="$crawl-url-last-modified and number($crawl-url-last-modified) > 0 and $last-modified and $last-modified = 'true' and not(content[@name='last-modified'])">
    <content name="last-modified" action="none" weight="{$last-modified-weight}" type="text">
      <xsl:call-template name="print-date">
        <xsl:with-param name="secs" select="$crawl-url-last-modified" />
      </xsl:call-template>
    </content>
  </xsl:if>
  <xsl:if test="$crawled-date and $crawled-date = 'true' and $crawl-url-at and $crawl-url-at != '' and number($crawl-url-at) > 0">
    <content name="crawled-date" action="none" weight="{$crawled-date-weight}" type="text">
      <xsl:call-template name="print-date">
        <xsl:with-param name="secs" select="$crawl-url-at" />
      </xsl:call-template>
    </content>
  </xsl:if>
</xsl:template>

<xsl:template match="content[@name='last-modified' and @seconds and not(* or text() or comment())]">
  <content>
    <xsl:copy-of select="@*"/>
    <xsl:call-template name="print-date">
      <xsl:with-param name="secs" select="@seconds" />
    </xsl:call-template>
  </content>
</xsl:template>

<xsl:template name="print-date">
  <xsl:param name="secs" />
  <xsl:param name="duration" select="concat('P0Y0M0DT0H0M', $secs, 'S')" />

  <xsl:attribute name="seconds">
    <xsl:value-of select="$secs"/>
  </xsl:attribute>

  <xsl:variable name="d" select="date:add('1970-01-01T00:00:00Z', $duration)" />

  <xsl:value-of select="substring(date:month-name($d), 1, 3)" />
  <xsl:text> </xsl:text>
  <xsl:value-of select="date:day-in-month($d)" />,
  <xsl:value-of select="date:year($d)" />
  <xsl:text> </xsl:text>
  <xsl:value-of select="format-number(date:hour-in-day($d), '00')" />
  <xsl:text>:</xsl:text>
  <xsl:value-of select="format-number(date:minute-in-hour($d), '00')" />
  <xsl:text>:</xsl:text>
  <xsl:value-of select="format-number(date:second-in-minute($d), '00')" />
  <xsl:text> GMT</xsl:text>
</xsl:template>

<!-- *******************************************
               Truncate long titles
     ******************************************* -->

<xsl:template match="content[@name='title' and $max-title-length > 0]">
  <!-- Intelligent streams: if language detected is a language defined in the intelligent streams option XML, add the corresponding vse-index-stream to the content. -->
    <xsl:variable name="self" select="." />
    <xsl:variable name="c" select="$self[viv:test(@name, $language-index-stream-contents, 'wc-set')]"/>

  <xsl:variable name="indexing-stream">
    <xsl:if test="$language-index-stream-enabled and $language-index-stream-enabled='true' and not(vse-index-stream) and $c">

      <xsl:variable name="html"> 
        <xsl:call-template name="language-text"> 
          <xsl:with-param name="c" select="$c[not(@type) or @type != 'text']"/> 
        </xsl:call-template> 
      </xsl:variable>
 
      <xsl:variable name="text"> 
        <xsl:call-template name="language-text"> 
          <xsl:with-param name="c" select="$c[@type = 'text']"/> 
          <xsl:with-param name="len" select="string-length($html)"/> 
        </xsl:call-template> 
      </xsl:variable> 


      <xsl:variable name="len" select="string-length($html) + string-length($text)"/>
      <xsl:if test="($len >= $language-index-stream-min-bytes)"> 
        <xsl:variable name="l" select="viv:classify-language($html, 'html', $text, 'text')"/> 
        <xsl:variable name="liso" select="viv:str-to-node($language-index-stream-options)" />
        <xsl:if test="$liso/output-stream[viv:match($l, @language)]">
          <xsl:copy-of select="$liso/output-stream[viv:match($l, @language)]/vse-index-stream" />
        </xsl:if>
      </xsl:if>
    </xsl:if>
  </xsl:variable>

  <xsl:copy>
    <xsl:attribute name="type">text</xsl:attribute>
    <xsl:apply-templates select="@*|comment()|*" />
    <xsl:copy-of select="$indexing-stream" />
    <xsl:call-template name="chop">
      <xsl:with-param name="text" select="." />
      <xsl:with-param name="max-length" select="$max-title-length" />
    </xsl:call-template>
  </xsl:copy>
  <xsl:apply-templates mode="content" select="."/>
</xsl:template>


<!-- Truncate strings -->

<xsl:template name="chop">
  <xsl:param name="text" />
  <xsl:param name="max-length" />

  <xsl:variable name="t" select="normalize-space(viv:replace($text, '&#173;', '', 'g'))" />

  <xsl:choose>
    <xsl:when test="string-length($t) > $max-length">
      <xsl:variable name="t-hacked" select="substring($t, 1, $max-length)" />
      <xsl:value-of select="viv:replace($t-hacked, '[^[:space:],\.;:>]*$', '')" />
      <xsl:text>...</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$t" />
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<!-- Placeholders for the hooks -->

<xsl:template mode="document" match="*"/>
<xsl:template mode="document-attributes" match="*"/>
<xsl:template mode="content" match="*"/>
<xsl:template mode="content-attributes" match="*"/>

]]></parser></converter><converter type-in="application/vxml-unnormalized" type-out="application/vxml" elt-id="2112" /></converters></vse-config><vse-status version="6.0" which="live" token="UebKbgE3hBYB" config-md5="80f57392a585b90929748ff5197b115c" crawler-config-md5="ee96c1dab059cc0c3825a4cc8f8025f9" indexer-config-md5="2f0d5e02d30be7b1e9f05eebab7b96ab" curr-config-md5="80f57392a585b90929748ff5197b115c"><crawler-status config-md5="ee96c1dab059cc0c3825a4cc8f8025f9" time="1374079696" elapsed="92" this-elapsed="92" host="all" n-input="49" n-output="40" n-errors="9" n-http-errors="0" n-http-location="0" n-filtered="0" n-robots="0" conversion-time="56293" n-sub="35" n-bytes="87311043.000000" n-dl-bytes="87311043.000000" converted-size="84752214.000000" n-pending="0" n-redirect="0" n-duplicates="0" n-deleted="0" n-cache-complete="0" n-awaiting-index-input="0" n-offline-queue="0" n-awaiting-index-reply="0" n-pending-internal="0" n-awaiting-gate="0" n-awaiting-input="0" n-error-rows="18" complete="complete" idle="idle" expected-stop-time="1374079696" final="final" service-status="stopped"><converter-timings total-ms="56293"><converter-timing timing-name="HTML to XML" n="1" ms="367" bytes-in="24603" bytes-out="17859" /><converter-timing timing-name="unknown -> text/plain" n-check="8" ms-check="0" bytes-in-check="664" /><converter-timing timing-name="Text to XML" n="34" ms="22424" bytes-in="84727611" bytes-out="84646310" /><converter-timing timing-name="Type normalization" n-check="8" ms-check="0" bytes-in-check="664" /><converter-timing timing-name="Guess content" n="43" ms="1311" bytes-in="87311043" bytes-out="87311043" /><converter-timing timing-name="Binary file extensions (filter)" n-check="43" ms-check="32" bytes-in-check="3675" /><converter-timing timing-name="Normalization" n="35" ms="31264" bytes-in="84664169" bytes-out="84697297" /><converter-timing timing-name="unknown -> application/dbf" n-check="8" ms-check="0" bytes-in-check="664" /></converter-timings><crawl-remote-all-status><crawl-remote-server-status /><crawl-remote-client-status /></crawl-remote-all-status><crawl-hops-output><crawl-hop hop="0" n="5" /><crawl-hop hop="1" n="35" /></crawl-hops-output><crawl-hops-input><crawl-hop hop="0" n="0" /><crawl-hop hop="1" n="0" /></crawl-hops-input></crawler-status><vse-index-status identifier="UebK0w24LhaV" slice="0" n-slices="1" version="8.2-3-build132 ebe8e2fafccedbb0299eedc09ede0da2" service-version="8.2-3-build132 9d0141f65c234e82ac34e67481bbb723" start-time="1374079605" indexing-time="108" indexed-urls="40" indexed-datas="35" indexed-docs="35" indexed-contents="245" indexed-bytes="84686319" error-datas="0" error-items="0" n-docs="35" max-docs="35" config-md5="2f0d5e02d30be7b1e9f05eebab7b96ab" running-time="108" input-port="60610" input-token="UebKdgC5cxaV" channel-port="56522" channel-token="UebKdgC5qxaV" idle="idle" idle-time="14" idle-exit="86400" service-status="running"><vse-serving port="49224" n-queries="0" n-cached-queries="0" n-pings="0" n-documents="0" n-no-documents="0" ms-queries="0" n-threads="1" n-idle-threads="1" q-p-s-1="0" q-p-s-5="0" q-p-s-15="0" /><vse-index-file name="viv_idx_lk1oiu" fname="./viv_idx_lk1oiu" type="index" size="159726592" at="1374079694" n-docs="35" max-docs="35" min-docid="0" max-docid="34"><vse-index-content name="doc#" n="35" words="0" /><vse-index-content name="last-modified" n="35" words="35" /><vse-index-content name="rights#" n="35" words="0" /><vse-index-content name="host" n="35" words="140" /><vse-index-content name="acl#" n="70" words="4552908" /><vse-index-content name="snippet" n="35" words="2275521" /><vse-index-content name="url" n="35" words="442" /><vse-index-content name="url#" n="35" words="2276524" /><vse-index-content name="size" n="35" words="35" /><vse-index-content name="filetype" n="35" words="35" /><vse-index-content name="language" n="34" words="34" /><vse-index-content name="title" n="1" words="2" /></vse-index-file><vse-index-cache-statuses block-size="8192"><vse-index-cache-status fname="./viv_idx_lk1oiu" core-size="2766848"><vse-index-cache-status-segment i="0" size="8192" allocated="8192" last="0" /><vse-index-cache-status-segment i="1" size="89530368" allocated="89530368" last="0" /><vse-index-cache-status-segment i="2" size="67411968" allocated="67411968" last="0" /><vse-index-info max-uncompressed-size="0"><vse-index-stream stem="depluralize" kb="none" segmenter="none" id="0" delanguage="true" wildcard-stem="case" wildcard-delanguage="true" segmenter-version="1"><vse-tokenizer name="simple" version="2" /></vse-index-stream></vse-index-info></vse-index-cache-status></vse-index-cache-statuses><vse-index-merging-status><vse-index-merger-status max-size="10" total-ms="2942"><vse-index-merge-status n-segments="5" n-indices="0" start="1374079693" to-read="156237824" read="156237824" written="156950528" end="1374079696" /></vse-index-merger-status><vse-index-merger-status min-size="10" max-size="1000" /><vse-index-merger-status min-size="1000" max-size="50000" /><vse-index-merger-status min-size="50000" /></vse-index-merging-status><reconstructor-statuses ms="3329" n-pending="0" priority="0"><reconstructor-status n-to-do="35" n-done="35" start="1374079696" end="1374079699" /><value-set-field name="last-modified" type="date" arena-id="-1" n-instances="35" data-bytes="175" meta-bytes="0" state="alive" /></reconstructor-statuses><reconstructor-statuses n-pending="0" priority="0"><value-set-field name="last-modified" type="date" arena-id="-1" n-instances="35" data-bytes="175" meta-bytes="0" state="alive" /></reconstructor-statuses><reconstructor-statuses n-pending="0" priority="1"><value-set-field name="last-modified" type="date" arena-id="-1" n-instances="35" data-bytes="175" meta-bytes="0" state="alive" /></reconstructor-statuses><la-scores-statuses /><vse-index-streams><vse-index-stream stem="depluralize" kb="none" segmenter="none" id="0" delanguage="true" wildcard-stem="case" wildcard-delanguage="true" segmenter-version="1"><vse-tokenizer name="simple" version="2" /></vse-index-stream></vse-index-streams><vse-index-builder-status elapsed="19.439" n-urls="0" n-segments="0" ms="17027" /></vse-index-status></vse-status><vse-run which="live"><vse-index><run pid="5781" path="/var/www/html/vivisimo//data/search-collections/5a1/content-size-4/crawl1" cmd="/var/www/html/vivisimo/bin/indexer-service" start-time="1374079605" cmd-line="'/var/www/html/vivisimo/bin/indexer-service' '--go' '/var/www/html/vivisimo//data/search-collections/5a1/content-size-4/crawl1' '61178'" pipe-name="/var/www/html/vivisimo/data/search-collections/5a1/content-size-4/crawl1/indexer-service.pipe" /></vse-index></vse-run><collection-service-status live-crawl-date="1374079598"><remote-status user="gary_testing" password="{vcrypt}TMWiymi8UsQ9QvtqWkxuhw==" email="vbrusilovsky@vivisimo.com" admin-url="http://testbed6-8.test.vivisimo.com/vivisimo/cgi-bin/admin" /></collection-service-status><hidden><vse-meta name="content-size-4" creator="gary_testing" create-time="1187357632" elt-id="1" max-elt-id="1" which="live" /></hidden><vse-meta name="content-size-4" creator="gary_testing" create-time="1187357632" elt-id="1" max-elt-id="1"><proto-section label="Directories" section="Directories"><declare tag="vse-meta-info" name="live-crawl-dir" type="directory"><label><![CDATA[Live data]]></label><description><p><![CDATA[The directory to be used for live crawling and indexing
	data.]]></p><p><![CDATA[When the collection is recrawled or refreshed, the data
	directory will toggle between live and staging. This allows a
	staging version of the collection to be created while the live
	version continues to run.]]></p></description></declare><declare tag="vse-meta-info" name="staging-crawl-dir" type="directory"><label><![CDATA[Staging data]]></label><description><p><![CDATA[The directory to be used for staging crawling and indexing
	data.]]></p><p><![CDATA[When the collection is recrawled or refreshed, the data
	directory will toggle between live and staging. This allows a
	staging version of the collection to be created while the live
	version continues to run.]]></p></description></declare><declare tag="vse-meta-info" name="cache-dir" type="string"><label><![CDATA[Result cache]]></label><description><![CDATA[
        The directory in which to store result cache files. By
        default, the result cache is stored in the
        ]]><incode><![CDATA[data/search-collections/]]></incode><i><![CDATA[XYZ]]></i><incode><![CDATA[/]]></incode><i><![CDATA[collection-name]]></i><incode><![CDATA[/cache]]></incode><![CDATA[
        subdirectory of your installation directory. XYZ is an
	internally-calculated hash based on the collection name.
      ]]></description></declare></proto-section><proto-section label="Advanced collection features" section="Advanced_collection_features"><declare tag="vse-meta-info" name="refresh" type="enum" enum-values="partial|full" deprecated="deprecated"><label><![CDATA[Fast refresh]]></label><description><![CDATA[
        This refresh mode requires that certain conditions be true
        regarding the equivalance of keys and urls in the crawl.  If
        these conditions are met, this mode can be used to refresh a
	collection much more quickly. A ]]><i><![CDATA[partial]]></i><![CDATA[ refresh
        should be used if you can generate a set of deletes manually
        (for example, using a database). A ]]><i><![CDATA[full]]></i><![CDATA[ refresh should
        be used for filesystem crawling or other crawls in which the
        only way to identify deletes is to test each file.
      ]]></description></declare><declare name="read-only" type="flag" tag="vse-meta-info" hidden="hidden" /><declare tag="vse-meta-info" name="enable-remote" type="flag"><label><![CDATA[Enable remote push]]></label><description><![CDATA[
        Remote push allow this collection's data, configuration and
        state to be pushed to remote machines to provide load balancing,
        fault-tolerance and backup.  Enabling this option will allow you
        to edit the remote configuration in the admin tool.
      ]]></description></declare></proto-section><proto-section label="General collection information" section="General_collection_information"><declare tag="vse-meta-info" name="maintainers" type="user-set" user-set-permission="admin-user"><label><![CDATA[Maintainers]]></label></declare><declare tag="vse-meta-info" name="desc" type="xml" dont-escape="dont-escape"><label><![CDATA[Description]]></label></declare></proto-section></vse-meta></vse-collection></full></interaction>